<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Tiiktak&#39;s -- 编程学习与技术分享</title>
    
    <meta name="description" content="Hey You">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s -- 编程学习与技术分享">
    
    
    
  </head>
  <body class="list home">
    <header class="header">
      <div class="wrap">
        
        <h1 class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s -- 编程学习与技术分享</a></h1>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="https://konosuba.xyz/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">








<article class="post-entry">
  <header class="entry-header">
    <h2>分类(classification)与回归(regression)的区别与关系</h2>
  </header>
  <section class="entry-content">
   <p> 分类与回归是监督学习中的两个主要任务，它们即对应了监督学习中“学习”的部分
分类模型与回归模型的本质其实一样。分类模型可将回归模型的输出离散化，回归模型也可将分类模型的输出连续化
例如：
Linear Recognition 线性回归 使用 y = wx &#43; b 的形式，y就是模型的输出，是一个连续值，所以可以用于处理回归问题
Logistic Recognition 逻辑回归 一般作为分类问题的首选算法，logistic回归只是用到了回归算法，但是其输出的结果是决策边界，是不连续的，所以它其实是分类，而不是回归
二分类 将 y = wx &#43; b 利用激活函数（常用sigmoid函数）映射到 (0,1) 中。再选定一个阈值，将输出分为两类。
多分类 先得到n组w不同的 y = wx &#43;b ，之后进行归一化（例如使用Softmax函数），从而得到在n个类上的概率，即可解决多分类问题
回归问题的应用场景 回归问题通常是用来预测一个值，如预测房价、未来的天气情况等等。例如一个产品的实际价格为500元，通过回归分析预测值为499元，我们认为这是一个比较好的回归分析。
一个比较常见的回归算法是线性回归算法（LR）。
另外，回归分析用在神经网络上，其最上层是不需要加上softmax函数的，而是直接对前一层累加即可。回归是对真实值的一种逼近预测。
分类问题的应用场景 分类问题是用于将事物打上一个标签，通常结果为离散值。
例如判断一幅图片上的动物是一只猫还是一只狗，分类通常是建立在回归之上，分类的最后一层通常要使用softmax函数进行判断其所属类别。
分类并没有逼近的概念，最终正确结果只有一个，错误的就是错误的，不会有相近的概念。
最常见的分类方法是逻辑回归，或者叫逻辑分类。
总结 一个小测验：假设你经营着一家公司，你想开发学习算法来处理这两个问题：
 你有一大批同样的货物，想象一下，你有上千件一模一样的货物等待出售，这时你想预测接下来的三个月能卖多少件？
 你有许多客户，这时你想写一个软件来检验每一个用户的账户。对于每一个账户，你要判断它们是否曾经被盗过？
  那这两个问题，它们属于分类问题、还是回归问题?
 问题一是一个回归问题，因为你知道，如果我有数千件货物，我会把它看成一个实数，一个连续的值。因此卖出的物品数，也是一个连续的值。
 问题二是一个分类问题，因为我会把预测的值，用 0 来表示账户未被盗，用 1 表示账户曾经被盗过。所以我们根据账号是否被盗过，把它们定为0 或 1，然后用算法推测一个账号是 0 还是 1，因为只有少数的离散值，所以我把它归为分类问题。
  ...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.6</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E5%88%86%E7%B1%BBclassification%E4%B8%8E%E5%9B%9E%E5%BD%92regression%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%B3%E7%B3%BB/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>C&#43;&#43;解决假币问题</h2>
  </header>
  <section class="entry-content">
   <p> 题目 一个袋子里有30个银币，其中一枚是假币，并且假币和真币一模一样，肉眼很难分辨，目前只知道假币比真币重量轻一点。请问，如何区分出假币？
分析 首先为每个银币编号，然后将所有的银币等分为两份，放在天平的两边。这样就将区分30个银币的问题变为区别两堆银币的问题。
因为假币分量较轻，因此天平较轻的一侧中一定包含假币。再将较轻的一侧中银币等分为两份，重复上述做法。直到剩下两枚银币，便可用天平直接找出假银币。类似于二分法
代码 由于这个是自己做的一个练习题，没有使用OJ判题，所以自己利用随机数生成银币的重量和假币相关信息
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ctime&gt; using namespace std; void generate_seq(int coin[]) { srand(time(0)); int coin_weight = rand() % 100; int fake_weight = rand() % coin_weight; int fake_add = rand() % 30; for (int i = 1; i &lt;= 30; i&#43;&#43;) { if (i == fake_add) coin[i] = fake_weight; else coin[i] = coin_weight; } cout &lt;&lt; &#34;fake_add=&#34; &lt;&lt; fake_add &lt;&lt; endl; cout &lt;&lt; &#34;fake_weight=&#34; &lt;&lt; fake_weight &lt;&lt; endl; } void show_seq(int coin[]) { for (int i = 1; i &lt;= 30; i&#43;&#43;) { cout &lt;&lt; coin[i] &lt;&lt; &#34; &#34;; } cout &lt;&lt; endl; } int find_fake(int coin[], int begin, int end) { if (begin == end) return begin; double mid = (begin &#43; end) / 2; int weight_a = 0, weight_b = 0; if ((end - begin &#43; 1) % 2 == 0) //可等分 { for (int i = begin; i &lt;= (int)mid; i&#43;&#43;) weight_a &#43;= coin[i]; for (int i = (int)mid &#43; 1; i &lt;= end; i&#43;&#43;) weight_b &#43;= coin[i]; cout &lt;&lt; begin &lt;&lt; &#34; &#34; &lt;&lt; end &lt;&lt; &#34; &#34; &lt;&lt; mid &lt;&lt; endl; cout &lt;&lt; weight_a &lt;&lt; &#34; &#34; &lt;&lt; weight_b &lt;&lt; endl; if (weight_a &lt; weight_b) find_fake(coin, begin, (int)mid); else find_fake(coin, (int)mid&#43;1, end); }else //不可等分，中间留一个mid { for (int i = begin; i &lt; mid; i&#43;&#43;) weight_a &#43;= coin[i]; for (int i = mid &#43; 1; i &lt;= end; i&#43;&#43;) weight_b &#43;= coin[i]; cout &lt;&lt; begin &lt;&lt; &#34; &#34; &lt;&lt; end &lt;&lt; &#34; &#34; &lt;&lt; mid &lt;&lt; endl; cout &lt;&lt; weight_a &lt;&lt; &#34; &#34; &lt;&lt; weight_b &lt;&lt; endl; if (weight_a &lt; weight_b) find_fake(coin, begin, (int)mid - 1); else if (weight_a &gt; weight_b) find_fake(coin, (int)mid &#43; 1, end); else return mid; } } int main() { //产生随机数列 int coin[31]; generate_seq(coin); //打印数列 show_seq(coin); //找 int fake_add = find_fake(coin, 1, 30); cout &lt;&lt; &#34;fake_add=&#34; &lt;&lt; fake_add &lt;&lt; endl; cout &lt;&lt; &#34;fake_weight=&#34; &lt;&lt; coin[fake_add] &lt;&lt; endl; return 0; }  ...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.12.30</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/c-%E8%A7%A3%E5%86%B3%E5%81%87%E5%B8%81%E9%97%AE%E9%A2%98/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>百度搜索资源平台用crul做链接主动推送</h2>
  </header>
  <section class="entry-content">
   <p>引 最近在百度站长平台加入了这个博客，由于之前在Google上都是直接提交sitemap地址，但是在百度索引sitemap实在太慢了，所以还是选择使用它推荐的crul主动推送方式，在这做个记录
在Windows上安装配置crul 进入curl的官网下载最新的Windows版的binary the curl project安装包
下载完成后解压到任意目录下
之后进入系统属性-&gt;高级系统设置-&gt;高级-&gt;环境变量-&gt;系统变量
新建一个变量，命名为curl，变量值选择之前解压的文件夹-&gt;bin文件夹-&gt;curl.exe
一路保存
之后打开cmd，敲入curl，输出如图，则配置成功
使用curl推送链接 由于使用curl推送链接需要一个只有链接地址的文件，然而sitemap很明显不符合这个条件，所以需要先利用这个在线工具将网站中的链接提取出来
如图，将图中右侧框中的链接复制到一个新建的txt文档，命名为urls.txt
然后在cmd中进入txt文件所在目录，执行百度搜索资源平台给的推送命令，例如：
如果有类似以下的输出，则说明推送成功！
{ &#34;remain&#34;:4999998, &#34;success&#34;:2, &#34;not_same_site&#34;:[], &#34;not_valid&#34;:[] }  在服务器自动推送 很明显，现在这种必须要每次手动推送，很耗费能量，所以之后会试着在网站服务器端配置自动推送，这样才是真正的自动推送嘛...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.12.3</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E8%B5%84%E6%BA%90%E5%B9%B3%E5%8F%B0%E7%94%A8crul%E5%81%9A%E9%93%BE%E6%8E%A5%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Tesseract-OCR样本训练方法</h2>
  </header>
  <section class="entry-content">
   <p>我们通常使用jTessBoxEditor训练工具进行训练，由于该工具是用Java开发的，所以在安装这个软件之前要保证电脑中有Java环境，这里就不介绍了。
安装jTessBoxEditor 可以在这里下载到最新版安装包
把下载得到的压缩包解压到任意位置，双击其中的train.bat文件，等待一会，弹出窗口就可以开始训练了
制作训练样本 生成tif文件 打开软件，选择Tools-&gt;Merge TIFF，文件类型选择ALL Image Files，选择所有要训练的样本图片，打开
之后会又弹出窗口，文件名需要自己设定，注意要按照格式设置：
[lang].[fontname].exp[num].tif
其中lang为语言名称，fontname为字体名称，num为序号。这三项都可以自己定义
这里我们设置为captcha.font.exp0.tif，文件类型TIFF，保存
生成box文件 将之前生成的captcha.font.exp0.tif复制到Tesseract-OCR的安装目录
打开cmd进入安装目录，执行命令
tesseract.exe num.font.exp0.tif num.font.exp0 batch.nochop makebox  将.box文件和.tif文件放在同一文件夹
手动调整 打开jTessBoxEditor工具，点击Box Editor-&gt;Open，选择打开之前生成的.box文件
软件中便会显示Tesseract自动标记识别的字符，接下来就需手动调整每一张的字符框和识别结果
全部修改完成后，选择Save保存即可
训练 先新建一个名为font_properties的文件，注意，只是文件，没有后缀！打开后，内容输入
captcha 0 0 0 0 0  这里全取值为0，表示字体不是粗体、斜体等等
之后在命令行分别运行命令：
shapeclustering.exe -F font_properties -U unicharset captcha.font.exp0.tr mftraining.exe -F font_properties -U unicharset captcha.font.exp0.tr cntraining.exe captcha.font.exp0.tr  之后给文件 inttemp，normproto，pffmtable，shapetable，unicharset 添加前缀captcha.，也就是我们的字体名
生成语言库 命令
combine_tessdata.exe captcha.  会生成一个captcha.traineddata文件，将其复制到Tesseract-OCR安装目录中的tessdata文件夹即可
使用训练结果 在调用tesseract或pytesseract时，只需添加参数lang=“captcha”（我们的字体名），程序就会自动调用啦...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.11.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/tesseract-ocr%E6%A0%B7%E6%9C%AC%E8%AE%AD%E7%BB%83%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Tesseract-OCR安装与python中使用</h2>
  </header>
  <section class="entry-content">
   <p>安装Tesseract-OCR 在官网下载最新的Windows安装包，双击运行
根据需要选择，一路Next，直到这个页面
在Additional language data(download)中选择要下载的其他语言的数据，之后程序会自动下载。一直到安装成功
配置环境变量 进入高级系统设置，选择高级-&gt;环境变量
选中系统变量中Path-&gt;编辑
新建一项，地址为Tesseract-OCR的安装目录即可（例如C:\Program Files\Tesseract-OCR）
可以通过在控制台中输入tesseract命令来检查是否配置成功，输出如图即表示成功
配置Python 直接使用pip install pytesseract进行安装
pytesseract 功能  get_tesseract_version　返回系统中安装的Tesseract版本。 image_to_string　将图像上的Tesseract OCR运行结果返回到字符串 image_to_boxes　返回包含已识别字符及其框边界的结果 image_to_data　返回包含框边界，置信度和其他信息的结果 image_to_osd　返回包含有关方向和脚本检测的信息的结果  参数 image_to_data(image, lang=None, config=&#39;&#39;, nice=0, output_type=Output.STRING)   image object　图像对象 lang String，Tesseract　语言代码字符串 config String　任何其他配置为字符串，例如：config=‘–psm 6’ nice Integer　修改Tesseract运行的处理器优先级。Windows不支持。 output_type　类属性，指定输出的类型，默认为string。  简单实例 识别一张图像中字符并直接输出
import pytesseract im = &#34;C:/Users/1/Desktop/test.jpg&#34; result = pytesseract.image_to_string(im) print(result)  这样识别到的字符就会转化成字符串输出...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.11.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/tesseract-ocr%E5%AE%89%E8%A3%85%E4%B8%8Epython%E4%B8%AD%E4%BD%BF%E7%94%A8/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>利用MLS移动最小二乘法对图像变形</h2>
  </header>
  <section class="entry-content">
   <p>这是我的【项目笔记】利用OpenCV的MLS图像扭曲变形实现中的第一部分
本文主要对MLS进行了一定讲解
 先简单了解一下什么是最小二乘法
最小二乘法 当我们在测量某个值y时，由于误差的存在，可能多次测量的结果不尽相同
我们把多次测量得到的不同结果yi画在同一坐标系中
同时将猜测的实际值y也画在坐标系中
每个yi和y都有一个差值| y - yi |，称为误差
记所有误差的平方和
由于实际值y是我们猜测的，所以它的值可以变化，同时误差的平方和ε也会随之改变
于是高斯或是法国科学家勒让德就提出使误差的平方和最小的 y 就是真值，这是基于，如果误差是随机的，应该围绕真值上下波动
这就是最小二乘法，即
此外，经证明得出误差的分布服从正态分布（不愧是天下第一分布），这里就不证明了
总的来说，对于被选择的参数，应该使算出的函数曲线与观测值之差的平方和最小。用函数表示为：
最小化问题的精度，依赖于所选择的函数模型
移动最小二乘法 移动最小二乘法与传统的最小二乘法相比，有两个比较大的改进：
  拟合函数的建立不同。这种方法建立拟合函数不是采用传统的多项式或其它函数，而是由一个系数向量 a(x)和基函数 p(x)构成， 这里a(x)不是常数，而是坐标 x 的函数。
 引入紧支（ Compact Support）概念。认为点x处的值 y只受 x附近子域内节点影响，这个子域称作点 x 的影响区域， 影响区域外的节点对 x的取值没有影响。在影响区域上定义一个权函数w(x)，如果权函数在整个区域取为常数，就得到传统的最小二乘法。
  节选自《基于移动最小二乘法的曲线曲面拟合-曾清红》
 利用MLS变换图像 这一部分，我主要参考了论文《Image Deformation Using Moving Least Squares》中的内容
考虑由用户设定锚点来对图像变形进行控制的情况，首先进行准备工作，推导出公式
准备工作 设p为一组控制点，q是它对应的变形位置
对于图像中的某一点v，有最小的仿射变换lv(x)，使
成立。其中pi和qi是行向量，权值wi满足
各点权重wi 由于对于每个v都有不同的wi的值，称之为移动最小二乘最小化（a Moving Least Squares minimization）。对于每个v都有不同的lv(x)
此时定义变形函数f(x) = lv(x)，可见当v接近pi时，wi趋于无穷、f(pi) = qi，此外若qi = pi，则lv(x) = x、f(v) = v...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.11.7</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E5%88%A9%E7%94%A8mls%E7%A7%BB%E5%8A%A8%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%AF%B9%E5%9B%BE%E5%83%8F%E5%8F%98%E5%BD%A2/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>【项目笔记】利用OpenCV的MLS图像扭曲变形实现</h2>
  </header>
  <section class="entry-content">
   <p>引 这学期开学的时候实验室接了个项目，要做一个类似Adobe Illustrator中的“操纵扭曲”功能的Demo
 就像这样
 需求分析 可见需要实现的功能核心就是通过鼠标的拖拽对图像进行扭曲变形，这里的变形主要可以分为两类：
 鼠标拖拽导致的普通变形
 在某一固定锚点基础上的旋转式变形
  确定方案 明确了这个后我便开始查阅资料，发现这篇paper 《Image Deformation Using Moving Least Squares》 中利用了MLS移动最小二乘来实现图像变形，其实现的效果和我们的目标极为相似，于是我也决定利用该算法来实现这个Demo
由于要利用鼠标拖拽进行操作，便选择使用Qt来进行图形化界面设计，然鹅我以前也没有用过Qt，因此学习了一些Qt基本知识
开始吧 明确了方案和目标后，便开始了漫长的学习&#43;实践：
 程序结构框架确定
 核心算法实现
 旋转式变形的实现
  在进行到这里之后，发现程序无法实现对某个关节的单独拉伸，于是我们考虑寻找图像中的骨骼，在关节的交点添加一些锚点进行固定
 图形骨骼查找  实现效果 最终项目完成，实现了这些功能，如图是个小小的演示
本文将会持续更新...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.10.23</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E5%88%A9%E7%94%A8opencv%E7%9A%84mls%E5%9B%BE%E5%83%8F%E6%89%AD%E6%9B%B2%E5%8F%98%E5%BD%A2%E5%AE%9E%E7%8E%B0/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>【转载】谷歌小姐姐搞出魔法画板：你随便画，补不齐算AI输</h2>
  </header>
  <section class="entry-content">
   <p>最近在研究手绘图形识别相关的内容，想起了这篇去年的文章，研究的内容也大致差不多，考虑使用Google的循环神经网络，于是转载过来记录一下
原文发表于2018-12-19
这两天，一个“魔法画板”在国外传疯了。
AI圈内外的灵魂画手们玩到根本停不下来，创造的惊喜画作能装满好几个美术馆。
这个画板背后，可不是一个普通的画画AI。它，会脑补。
随便画一笔，就能得到一只猫：
画个圆圈，变成猫：
画个三角，变成猫：
画个方块，变成猫：
真是万物皆可喵喵。
当然，你也可以不让它画猫，改成画狗。只要你设定了一个绘画的目标，之后随便画一笔，AI就能脑补出余下的画面。
这个“魔法”，是来自谷歌的吸猫少女Monica Dinculescu用Sketch RNN开发的。
因为她爱猫成痴，不仅自己头像是和自家喵子的合影，连个人主页域名都叫Meowni.ca，我们就叫她喵妮卡好了。
所以，受到创作者的影响，这个AI默认属性为吸猫爱好者，但除了猫之外，AI也会脑补许多其他内容，脑洞很大。
发布之后，众人竞相玩耍，好评如潮，2000多人点赞。
有人让AI画了满屏的骷髅，说，好美啊！
谷歌大佬David Ha也表示，他已经试过用各种基本形状来教导AI画羊了。
不止有魔力，还可以加戏 喵妮卡给应用起名为魔法画板 (Magic Sketchpad) ，也名副其实。
毕竟，只要画一笔，妈咪妈咪哄！一整张图就出现在眼前。
△ 你想要什么样的美人鱼？
而且，只要按一下选择栏左边的刷新按钮，AI就会根据刚才那一笔，不断为你展现新的画法。
一共有100多种东西可以画，青蛙，秋千，直升飞机，连龙猫里的猫巴士都有。
我是一只豆豆眼的猫头鹰：
我是一只很鬼魅的仙人掌：
为了这100多种选项，都能找到合适的色彩来诠释，画板还提供了18种颜色的画笔。
这样一来，就有数不清的排列组合。有大胆想法的小伙伴们，可以在魔法画板上尽情加戏了。
在你开始表演之前，量子位先抛抛砖：
鲸鱼喷出的不一定是水，也有可能是花。
牙刷上方温柔的曲线不一定是牙膏，也有可能是蜗牛。
另外，如果你还没想到，除了排列组合之外，还可以鬼畜啊。
一头鲸鱼喷水没什么，十几头鲸一起喷，就很有节奏感了 (误) 。
一个人做瑜伽太孤单了，十几个人一起做，姿态各不相同，清明瑜伽图岂不美哉？
不过虽然好玩，量子位似乎还是发现了一个bug，像猫巴士 (Catbus) 这种组合选项：画方成车，画圆成猫，无法兼顾。那么，怎样才能一步生成下面这样的效果呢？
想要体验一下的盆友，传送门照例在文末~
人家是有背景的 可能你已经发觉了，它的画风很像的谷歌推出的Quick, Draw!，中文名为“猜画小歌”。
是的，他们是一家人。
喵妮卡在推特上说了，她的魔法画板使用的就是Quick, Draw!数据集。
这个数据集里面，有5000万张画，分为345个类别。每一张画，都记录了画画的整个过程：画笔运动的方向，何时提笔，何时停止绘画。
如果你玩过猜画小歌，那这个数据集里，也有你的一份贡献。
既然使用的是Quick, Draw!数据集，模型基本上没有什么悬念。
正是Sketch-RNN。这是一个用Quick, Draw！数据集训练出来循环神经网络（RNN）。目标是让AI以类似人类的方式来画画，并概括出抽象的概念。
模型有这样的能力，做出来魔法画板也就没有那么难了。
你随手画个圈，就是为Sketch-RNN输入了一个序列，它可以根据这个序列和你选择要画的东西，预测接下来的序列：也就是补完这幅画。
虽然画风奇特，但画啥就有点像啥。
具体的实现代码，喵妮卡也全部放出来了。（传送门在文末。）
三种额外玩法 除了这个万物皆可喵的网页之外，喵妮卡所在的Google Magenta团队还用Sketch-RNN创作了几个不同的涂鸦应用。
9×N种预测，总能猜中你的心 你涂鸦的每一笔，都被我预料到了。
无论你画了个啥，我都能猜出你接下来准备如何下笔。
并且，我有无数种方案，只要点击predict，就可以出现新的9种图案。...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.10.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E8%BD%AC%E8%BD%BD%E8%B0%B7%E6%AD%8C%E5%B0%8F%E5%A7%90%E5%A7%90%E6%90%9E%E5%87%BA%E9%AD%94%E6%B3%95%E7%94%BB%E6%9D%BF%E4%BD%A0%E9%9A%8F%E4%BE%BF%E7%94%BB%E8%A1%A5%E4%B8%8D%E9%BD%90%E7%AE%97ai%E8%BE%93/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>第一个TensorFlow模型：摄氏度转换为华氏度</h2>
  </header>
  <section class="entry-content">
   <p>今天开始在看Udacity上的TensorFlow入门课程，其中构建的第一个神经网络模型就是将摄氏度转换成华氏度，于是在这里记录一下
公式 已知摄氏度转换成华氏度有数学公式：
f = c * 1.8 &#43; 32  而我们就要在不告知模型这个公式的前提下，通过告知一系列对应的摄氏度与华氏度样例，来训练它以实现摄氏度转华氏度这一功能
import dependencies 导入依赖项 需要引入TensorFlow与NumPy库构建神经网络
from __future__ import absolute_import, division, print_function, unicode_literals import tensorflow as tf import numpy as np  还需要引入logging以记录日志
import logging logger = tf.get_logger() #返回tf的日志实例 logger.setLevel(logging.ERROR)  Set up training data 建立训练数据 由于在这里我们使用的是监督式机器学习，所以准备两组链表celsius_q和fahrenheit_a分别代表摄氏温度与对应华氏温度，用来训练模型
celsius_q = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float) fahrenheit_a = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float) for i,c in enumerate(celsius_q): print(&#34;{} degrees Celsius = {} degrees Fahrenheit&#34;....</p>
  </section>
  <footer class="entry-footer">
    <time>2019.10.11</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E7%AC%AC%E4%B8%80%E4%B8%AAtensorflow%E6%A8%A1%E5%9E%8B%E6%91%84%E6%B0%8F%E5%BA%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%8E%E6%B0%8F%E5%BA%A6/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Python中eval()与format()</h2>
  </header>
  <section class="entry-content">
   <p>今天在做mooc课程《Python语言程序设计》的练习题时，遇到一道题，硬生生纠结了半个小时，结果发现答案居然只是短短的两行，这功力不够果然还是不行啊，用C的思维去写Python怕是要纠结死🤔
先看看题
题目 数值运算
描述 获得用户输入的一个字符串，格式如下：
M OP N  其中，M和N是任何数字，OP代表一种操作，表示为如下四种：&#43;, -, *, /（加减乘除）
根据OP，输出M OP N‬的运算结果，统一保留小数点后两位
注意：M和OP、OP和N之间可以存在多个空格，不考虑输入错误情况
示例输入‪ 10 &#43; 100 1 / 20  示例输出 110.00 0.05  解答 我最开始的想法是读入字符串，然后根据空格分为M、OP和N，之后再转换为int型进行计算
然而，我却完全忘记了Python有着eval()的存在….
eval() |eval()函数用来执行一个字符串表达式，并返回表达式的值 ‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫
eval(expression[, globals[, locals]])   参数
expression – 表达式
globals – 变量作用域，全局命名空间，若被提供，必须是一个字典对象
locals – 变量作用域，局部命名空间，若被提供，可以是任何映射对象
 可见，使用eval()后，就不需要我们自己对用户输入的算式进行处理，只需要直接调用，函数会自动帮我们计算结果
之后根据题意，我们还要将运算结果保留两位小数，这时format()就派上了用场
format() 这是一种格式化字符串的函数，基本语法是使用{}和: ‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮ |format()‫‬‪‬‪函数‬‪‬‪‬可以接受不限个参数，位置可以不按顺序
&gt;&gt;&gt; &#34;{} {}&#34;.format(&#34;hello&#34;, &#34;world&#34;) # 不设置指定位置，按默认顺序 &#39;hello world&#39; &gt;&gt;&gt; &#34;{0} {1}&#34;.format(&#34;hello&#34;, &#34;world&#34;) # 设置指定位置 &#39;hello world&#39; &gt;&gt;&gt; &#34;{1} {0} {1}&#34;....</p>
  </section>
  <footer class="entry-footer">
    <time>2019.10.10</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/python%E4%B8%ADeval%E4%B8%8Eformat/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="https://konosuba.xyz/page/4/">← Prev Page</a>
    
    
    <a class="next" href="https://konosuba.xyz/page/6/">Next Page →</a>
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s -- 编程学习与技术分享</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

