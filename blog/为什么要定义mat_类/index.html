<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>为什么要定义Mat_类 - Tiiktak&#39;s</title>
    
    <meta name="description" content="内容摘自《OpenCV入门教程》
 在读取矩阵元素时，以及获取矩阵某行的地址时，需要指定数据类型。这样首先需要不停地写&lt;uchar&gt;，让人感觉很繁琐，在繁琐和烦躁中容易犯错。
如下面代码中的错误，用at()获取矩阵元素时错误的使用了double类型。这种错误不是语法错误，因此在编译时编译器不会提醒。在程序运行时，at()函数获取到的不是期望的(i,j)位置处的元素，数据已经越界，但是运行时也未必会报错。这样的错误使得你的程序忽而看上去正常，忽而弹出“段错误”，特别是在代码规模很大时，难以查错。
如果使用Mat_类，那么就可以在变量声明时确定元素的类型， 访问元素时不再需要指定元素类型，即使得代码简洁，又减少了出错的可能性。
上面代码可以用Mat_实现，实现代码如下面例程里的第二个双重for循环。
#include &lt;iostream&gt; #include &quot;opencv2/opencv.hpp&quot; #include &lt;stdio.h&gt; using namespace std; using namespace cv; int main(int argc,char* argv[]) { Mat M(600, 800, CV_8UC1); for(int i = 0; i &lt; M.rows; &#43;&#43;i) { //获取指针时需要指定类型 uchar *p = M.ptr&lt;uchar&gt;(i); for(int j = 0; j &lt; M.cols; &#43;&#43;j) { double d1 = (double)((i &#43; j) % 255); //用at读像素时，需要指定类型 M.at&lt;uchar&gt;(i, j) = d1; double d2 = M.at&lt;uchar&gt;(i, j); } } //在变量声明时，指定矩阵元素类型 Mat_&lt;uchar&gt; M1 = (Mat_&lt;uchar&gt;&amp;)M; for(int i = 0; i &lt; M1.">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s">
    
    
    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-141514532-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'UA-141514532-1');
    </script>
    
    <script>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?0121c6813b611028681cd70e85594cb6";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>

  </head>
  <body class="single">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s</a></p>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">为什么要定义Mat_类</h1>
    <div class="post-meta">2019.9.18</div>
  </header>
  <div class="post-content"><blockquote>
<p>内容摘自《OpenCV入门教程》</p>
</blockquote>

<p>在读取矩阵元素时，以及获取矩阵某行的地址时，需要指定数据类型。这样首先需要不停地写<code>&lt;uchar&gt;</code>，让人感觉很繁琐，在繁琐和烦躁中容易犯错。</p>

<p>如下面代码中的错误，用<code>at()</code>获取矩阵元素时错误的使用了<code>double</code>类型。这种错误不是语法错误，因此在编译时编译器不会提醒。在程序运行时，<code>at()</code>函数获取到的不是期望的<code>(i,j)</code>位置处的元素，数据已经越界，但是运行时也未必会报错。这样的错误使得你的程序忽而看上去正常，忽而弹出“段错误”，特别是在代码规模很大时，难以查错。</p>

<p>如果使用<code>Mat_</code>类，那么就可以在<strong>变量声明时确定元素的类型</strong>， 访问元素时不再需要指定元素类型，即使得代码简洁，又减少了出错的可能性。</p>

<p>上面代码可以用<code>Mat_</code>实现，实现代码如下面例程里的第二个双重<code>for</code>循环。</p>

<pre><code class="language-c">#include &lt;iostream&gt;
#include &quot;opencv2/opencv.hpp&quot;
#include &lt;stdio.h&gt;
using namespace std;
using namespace cv;

int main(int argc,char* argv[])
{
    Mat M(600, 800, CV_8UC1);

    for(int i = 0; i &lt; M.rows; ++i)
    {
        //获取指针时需要指定类型
        uchar *p = M.ptr&lt;uchar&gt;(i);
        for(int j = 0; j &lt; M.cols; ++j)
        {
            double d1 = (double)((i + j) % 255);
            //用at读像素时，需要指定类型
            M.at&lt;uchar&gt;(i, j) = d1;
            double d2 = M.at&lt;uchar&gt;(i, j);
        }
    }

    //在变量声明时，指定矩阵元素类型
    Mat_&lt;uchar&gt; M1 = (Mat_&lt;uchar&gt;&amp;)M;
    for(int i = 0; i &lt; M1.rows; ++i)
    {
        //不需要指定元素类型，语言简洁
        uchar *p = M1.ptr(i);

       for(int j=0;j&lt;M1.cols;++j)
       {
            double d1=(double)((i+j)%255);
            //直接使用matlab风格的矩阵元素读写，简洁
            M1(i,j) = d1;
            double d2 = M1(i,j);
        }
    }

    return 0;
}
</code></pre>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'tiiktak';
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

