<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Tiiktak&#39;s</title>
    <link>https://tiiiktak.github.io/blog/</link>
    <description>Recent content in Blog on Tiiktak&#39;s</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 28 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://tiiiktak.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Links</title>
      <link>https://tiiiktak.github.io/blog/links/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/links/</guid>
      <description>Ritchie and his friends.</description>
    </item>
    
    <item>
      <title>灰度重心法</title>
      <link>https://tiiiktak.github.io/blog/%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E6%B3%95/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E6%B3%95/</guid>
      <description> 对于亮度不均匀的目标（如光斑，光条纹），灰度重心法可按目标光强分布求出光强权重质心坐标作为跟踪点，也叫*密度质心算法*。
将灰度值分布中的质心记作光条纹的中心 对于M * N大小的图像f，像素的灰度值凡是超过阈值T的均参与重心处理，于是重心坐标为： 灰度重心法公式 型心法 只可用于二值图像 灰度重心法version 1 灰度重心法version 2 </description>
    </item>
    
    <item>
      <title>Shell学习</title>
      <link>https://tiiiktak.github.io/blog/shell%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 26 Jun 2019 15:38:32 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/shell%E5%AD%A6%E4%B9%A0/</guid>
      <description>Shell脚本 是一种为shell编写的脚本程序
使用文本编辑器既能编写，拓展名不影响脚本执行
实例：
#!/bin/bash echo &amp;quot;Hello World&amp;quot;   ### 运行脚本 #### 作为可执行程序 将代码保存后，给文件添加可执行权限```+x``` ```sh chmod +x ./test.sh # ./test.sh #执行脚本  作为解释器参数  直接运行解释器，将文件作为其参数 这种方式不需要在文件开头指定解释器信息
/bin/sh test.sh  Shell变量 定义变量 your_name=&amp;quot;Tom&amp;quot;  注意：等号不能有空格
使用变量 在变量前加美元符号$ 还可在变量外添加大括号{}
echo $your_name echo ${your_name}  只读变量 使用readonly命令将变量定义为只读变量，值不能被改变
url=&amp;quot;baidu.com&amp;quot; readonly url  删除变量 使用unset变量删除变量
unset url  Shell字符串 可用单引号，或双引号，也可不用引号
单引号  单引号内任何字符都会原样输出，单引号字符串中变量无效 单引号字符串中不能出现单独一个的单引号，但可成对出现  双引号  双引号里可以有变量 双引号里可以出现转义字符  拼接字符串 text1=&#39;123&#39; text2=&#39;456&#39; echo ${text1}${text2} #输出123456  字符串长度 str1=&amp;quot;abcd&amp;quot; echo ${#str1} #输出4  提取子字符串 从字符串第2个字符开始截取4个字符：</description>
    </item>
    
    <item>
      <title>Vim学习</title>
      <link>https://tiiiktak.github.io/blog/vim%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 26 Jun 2019 10:33:16 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/vim%E5%AD%A6%E4%B9%A0/</guid>
      <description>vim分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode），底线命令（Last line mode）
命令模式 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。
常用命令：
 i 切换到输入模式，以输入字符 x 删除当前光标所在处的字符 : 切换到底线命令模式，以在最底一行输入命令  命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令
输入模式 常用：
 Esc 退出输入模式，切换到命令模式 Insert 切换光标为输入/替换模式，光标变成竖线/下划线  底线命令模式 基本命令： * q 退出程序 * w 保存文件
vim按键 移动光标 要进行多次移动，例如向下移动30行，可使用“30↓”的组合按键
 [Ctrl]+[f] 下一页 [Ctrl]+[b] 上一页 [Ctrl]+[d] 向下半页 [Ctrl]+[u] 向上半页 0 移动到该行最前面字符处 $ 移动到该行最后字符处 G 移动到档案最后一行 nG 一赌东道档案第n行 gg 移动到档案第一行  搜索替换  /word 向光标之下寻找名称为word的字符串 ？word 向光标之上寻找名称为word的字符串 n 重复前一个搜寻的动作 N 反向进行前一个搜寻动作 :n1,n2s/word1/word2/g 在n1与n2行之间寻找word1字符串，并用word2取代 :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2，并显示提示字符确认  删除、复制、粘贴  x,X x相当于del，X相当于Backspace dd 删除光标所在行 ndd 删除光标所在向下n行 d1G 删除光标所在到第一行所有数据 dG 删除光标所在到最后一行所有数据 yy 复制光标所在行 nyy 复制光标所在的向下n行 p,P p为将已复制的数据在光标下一行粘贴，P为粘贴在上一行 u 撤销 [Ctrl]+r 重做 .</description>
    </item>
    
    <item>
      <title>Linux文件</title>
      <link>https://tiiiktak.github.io/blog/linux%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 25 Jun 2019 13:23:08 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/linux%E6%96%87%E4%BB%B6/</guid>
      <description>[toc]
Linux文件基本属性 在Linux中可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：
[root@www /]# ls -l total 64 dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin dr-xr-xr-x 4 root root 4096 Apr 19 2012 boot ……  bin文件的第一个属性用d表示，d在Linux中代表该文件是一个目录文件 Linux中第一个字符代表这个文件时目录、文件、链接文件等 &amp;gt;* 当为[d]则是目录 &amp;gt;* 当为[-]则是文件 &amp;gt;* 若是[l]则表示为链接文档(link file) &amp;gt;* 若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) &amp;gt;* 若是[c]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)
接下来的字符中，三个为一组，且均为『rwx』 的三个参数的组合。其中，[r]代表可读(read)、[w]代表可写(write)、[x]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[-]，如图
Linux链接 Linux链接分为硬链接（Hard Link）和软链接（Symbolic Link）。默认情况，ln命令创建硬链接
硬链接 硬连接指通过索引节点来进行连接，多个文件名可以指向同一索引节点，删除其中任何一个不会影响其余文件名的访问，只有当最后一个连接被删除时，文件的数据块及其目录的连接才被释放
软链接 即符号链接，类似于Windows中快捷方式。两个文件名指向两个不同的节点号，若被指向的文件删除，链接仍存在，但指向一个无效的链接
Linux文件属主和属组 Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。
[root@www /]# ls -l total 64 drwxr-xr-x 2 root root 4096 Feb 15 14:46 cron drwxr-xr-x 3 mysql mysql 4096 Apr 21 2014 mysql ……  mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</description>
    </item>
    
    <item>
      <title>Linux操作学习 系统启动及目录</title>
      <link>https://tiiiktak.github.io/blog/linux%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 24 Jun 2019 11:51:27 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/linux%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%9B%AE%E5%BD%95/</guid>
      <description>Linux系统启动过程   内核的引导 运行init 系统初始化 建立终端 用户登录系统   内核的引导 计算机接通电源，BIOS开机自检，启动操作系统，操作系统接管硬件后，首先读入/boot目录下的内核文件
运行init init进程是所有进程的起点，没有它任何进程都不会启动。init程序首先需要读取配置文件/etc/inittab
运行级别 Linux允许为不同的场合，分配不同的开机启动程序，即“运行级别”(runlevel)。启动时根据运行级别，确定要运行哪些程序
Linux共7种运行级别: &amp;gt;* 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 &amp;gt;* 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 &amp;gt;* 运行级别2：多用户状态(没有NFS) &amp;gt;* 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 &amp;gt;* 运行级别4：系统未使用，保留 &amp;gt;* 运行级别5：X11控制台，登陆后进入图形GUI模式 &amp;gt;* 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
系统初始化 init配置文件中有一行：si::sysinit:/etc/rc.d/rc.sysinit，它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，主要完成一些系统初始化的工作，rc.sysinit是每个运行级别都要首先运行的重要脚本。
主要完成的工作：激活交换分区，检查磁盘，加载硬件模块及其他一些需要优先执行的任务
另外一行：15:5:wait:/etc/rc.d/rc 5，表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，接受5作为参数，执行/etc/rc.d/rc5.d/目录下所有rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。
而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。
这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。
至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&amp;rdquo;System Services&amp;rdquo;来自行设定。
建立终端 rc执行完毕，返回init。此时基本系统环境已设置好，各种守护进程已启动。
init接下来会打开6个终端，以便用户登录系统，即inittab中以下6行就是定义了6个终端：
1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6  2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式，同时显示文本登陆界面
用户登录系统 常用三种登陆方式： * 命令行登陆 * ssh登陆 * 图形界面登陆
命令行登陆 Linux的账号验证程序是login，login会接手mingetty传来的用户名作为用户名参数， 之后login对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login 将输出 nologin 文件的内容，然后退出。</description>
    </item>
    
    <item>
      <title>Python面向对象</title>
      <link>https://tiiiktak.github.io/blog/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 21 Jun 2019 15:23:06 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>类和实例 定义类 使用class关键字
class Student(object): #class 类名(继承类) 无继承类则使用object,也可省略 &amp;quot;&amp;quot;&amp;quot;docstring for Student&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, score): #初始属性，第一个参数永远是self，表示创建的实例本身 super (Student, self).__init__() self.name = name self.score = score def print_score(self) print(&#39;%s: %s&#39; % (self.name, self.score))  实例化 类名+（）
&amp;gt;&amp;gt;&amp;gt; bob = Student(&#39;Bob&#39;, 98) &amp;gt;&amp;gt;&amp;gt; bob.print_score() Bob: 98  创建实例后，可以自由地给一个实例变量绑定属性，如
&amp;gt;&amp;gt;&amp;gt; bob.school = &#39;SWUST&#39; &amp;gt;&amp;gt;&amp;gt; bob.school &#39;SWUST&#39;  访问限制  private私有变量：变量名以__开头 注意：__name__外部可以访问，是特殊变量  继承和多态 基类：
class Animal(object): def run(self): print(&#39;Animal is running...&#39;)  子类：</description>
    </item>
    
    <item>
      <title>Python函数式编程</title>
      <link>https://tiiiktak.github.io/blog/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 21 Jun 2019 10:50:55 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>[toc]
什么是函数式编程？ 函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言
高阶函数 Python中函数两个特性 &amp;gt; ### 变量可以指向函数 函数本身可以赋值给变量，通过变量可以调用函数
&amp;gt;&amp;gt;&amp;gt; f = abs &amp;gt;&amp;gt;&amp;gt; f(-10) 10   函数名是变量 把函数名看作变量，可将其指向其他对象，则无法调用原函数
&amp;gt;&amp;gt;&amp;gt; abs = 10 &amp;gt;&amp;gt;&amp;gt; abs(-10) Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; TypeError: &#39;int&#39; object is not callable   传入函数 由于变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
一个最简单的高阶函数：
def add(x, y, f) return f(x) + f(y)  当调用add(-5, -6, abs)时，函数计算abs(-5)+abs(-6)，返回11
 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式
 Python内建高阶函数 map()函数 |map() 函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回</description>
    </item>
    
    <item>
      <title>算法复杂度</title>
      <link>https://tiiiktak.github.io/blog/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Fri, 21 Jun 2019 10:40:29 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description> 算法复杂度  总共N个数据 一次操作记为O(1) N次操作记为O(n) 在大部分oj判题系统中时间限制为10^6 =1s  冒泡排序  操作次数: n+(n-1)+(n-2)+&amp;hellip;+n(n-1)/2  快速排序  递归处理数组，每次将数组按照key值在其左右区分出来：比key小放左边，比key大放右边
 例: 5 6 2 4 3 8 取首位（5）为key值
 4 3 2 5 6 8
 4 3 2 5 6 8
  </description>
    </item>
    
    <item>
      <title>Python中set集合</title>
      <link>https://tiiiktak.github.io/blog/python%E4%B8%ADset%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 20 Jun 2019 16:18:07 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E4%B8%ADset%E9%9B%86%E5%90%88/</guid>
      <description> set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
创建set 传入一个list，重复元素会被自动过滤，显示的顺序并不表示set是有序的
&amp;gt;&amp;gt;&amp;gt; s = set([1, 1, 2, 2, 3, 3]) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3}  添加元素 &amp;gt;&amp;gt;&amp;gt; s.add(4) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3, 4}  删除元素 &amp;gt;&amp;gt;&amp;gt; s.remove(3) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 4}  交并集 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3]) &amp;gt;&amp;gt;&amp;gt; s2 = set([2, 3, 4]) &amp;gt;&amp;gt;&amp;gt; s1 &amp;amp; s2 {2, 3} &amp;gt;&amp;gt;&amp;gt; s1 | s2 {1, 2, 3, 4}  </description>
    </item>
    
    <item>
      <title>Python中dict字典</title>
      <link>https://tiiiktak.github.io/blog/python%E4%B8%ADdict%E5%AD%97%E5%85%B8/</link>
      <pubDate>Thu, 20 Jun 2019 15:15:34 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E4%B8%ADdict%E5%AD%97%E5%85%B8/</guid>
      <description>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度
创建dict &amp;gt;&amp;gt;&amp;gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} &amp;gt;&amp;gt;&amp;gt; d[&#39;Michael&#39;] 95  内部实现方法 先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
加入数据 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
&amp;gt;&amp;gt;&amp;gt; d[&#39;Tony&#39;] = 99 &amp;gt;&amp;gt;&amp;gt; d {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  查询key是否存在 使用in &amp;gt;&amp;gt;&amp;gt; &#39;Thomas&#39; in d False &amp;gt;&amp;gt;&amp;gt; &#39;Bob&#39; in d True  使用get() 如果key不存在，返回None，或者自己指定的value
&amp;gt;&amp;gt;&amp;gt; d.get(&#39;Thomas&#39;) #返回None时Python交互环境不显示 &amp;gt;&amp;gt;&amp;gt; d.get(&#39;Thomas&#39;, -1) -1  删除key 删除一个key，用pop(key)方法，对应的value也会从dict中删除，返回删除的value
&amp;gt;&amp;gt;&amp;gt; d.pop(&#39;Bob&#39;) 75 &amp;gt;&amp;gt;&amp;gt; d {&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  注意 dict内部存放顺序与key放入顺序无关 dict的key必须是不可变对象 实质：哈希表</description>
    </item>
    
    <item>
      <title>Python常见数据类型——Tuple元组</title>
      <link>https://tiiiktak.github.io/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btuple%E5%85%83%E7%BB%84/</link>
      <pubDate>Thu, 20 Jun 2019 13:46:10 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btuple%E5%85%83%E7%BB%84/</guid>
      <description>tuple和list非常类似，但是tuple一旦初始化就不能修改
[toc]
创建tuple &amp;gt;&amp;gt;&amp;gt; classmates = (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)  此时，classmates这个tuple不能改变，它也没有append()，insert()这样的方法。
其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能将其赋值为另外的元素。
因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
空tuple &amp;gt;&amp;gt;&amp;gt; t = () &amp;gt;&amp;gt;&amp;gt; t ()  只有一个元素的tuple 错误写法 不能直接使用括号()!!!
&amp;gt;&amp;gt;&amp;gt; t = (1) &amp;gt;&amp;gt;&amp;gt; t 1 #定义的不是tuble，而是一个数  正解 加一个逗号，消除歧义
&amp;gt;&amp;gt;&amp;gt; t = (1,) &amp;gt;&amp;gt;&amp;gt; t (1,)  &amp;ldquo;可变&amp;rdquo;的tuble 当tuble中包含list元素时，仍然可以对list进行修改，tuble仍指向该list
&amp;gt;&amp;gt;&amp;gt; t = (1, [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]) &amp;gt;&amp;gt;&amp;gt; t[1][2] = &#39;a&#39; &amp;gt;&amp;gt;&amp;gt; t (1, [&#39;x&#39;, &#39;a&#39;, &#39;z&#39;])  个人理解：tuble相当于一个指针数组，指向每个元素，对元素本身的更改并不会影响tuble的指向</description>
    </item>
    
    <item>
      <title>Python常见数据类型——List列表</title>
      <link>https://tiiiktak.github.io/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%88%97%E8%A1%A8/</link>
      <pubDate>Thu, 20 Jun 2019 13:44:48 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%88%97%E8%A1%A8/</guid>
      <description>Python常见数据类型——List列表 list是一种有序的集合，可随时增删元素
[toc]
创建list &amp;gt;&amp;gt;&amp;gt; classmates = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &amp;gt;&amp;gt;&amp;gt; len(classmates) 3  访问某个位置元素 使用索引地址访问
&amp;gt;&amp;gt;&amp;gt; classmates[0] &#39;A&#39; &amp;gt;&amp;gt;&amp;gt; classmates[-1] #返回最后一项元素 &#39;C&#39;  追加元素到末尾 &amp;gt;&amp;gt;&amp;gt; classmates.append(&#39;D&#39;) &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  插入元素到指定位置 &amp;gt;&amp;gt;&amp;gt; classmates.insert(1, &#39;Here&#39;) #在指定位置放入元素 &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  删除元素 使用pop 指定索引地址删除，返回删除的值
&amp;gt;&amp;gt;&amp;gt; classmates.pop(0) &#39;A&#39; &amp;gt;&amp;gt;&amp;gt; classmates [&#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  使用del 指定索引地址删除，无返回值
&amp;gt;&amp;gt;&amp;gt; del classmates[1] &amp;gt;&amp;gt;&amp;gt;classmates [&#39;Here&#39;, &#39;C&#39;, &#39;D&#39;]  使用remove 删除指定值的第一次出现，无返回值</description>
    </item>
    
    <item>
      <title>图像基础-图像矩阵</title>
      <link>https://tiiiktak.github.io/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 06 Jun 2019 00:35:00 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5/</guid>
      <description>数字图像数据可以用矩阵来表示，因此可以采用矩阵理论和矩阵算法对数字图像进行分析和处理。
在使用OpenCV时，要特别注意其坐标轴与普通x-y轴的转换，我在实际使用过程中就经常在这上面翻车，还是不熟练
图为坐标对照图，转自CSDN，具体忘了</description>
    </item>
    
    <item>
      <title>图像基础-图像分类</title>
      <link>https://tiiiktak.github.io/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:49 +0800</pubDate>
      
      <guid>https://tiiiktak.github.io/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</guid>
      <description>  部分内容引用 CSDN爬金字塔的人
 计算机中， 通常以矩阵形式存储图像，根据颜色和灰度多少可以分为灰度图像、二值图像、索引图像和RGB图像
灰度图像  矩阵元素取值范围为[0, 255] （0-黑，255-白），数据类型一般为8位无符号整数【unit8】
 某些领域（如医学成像）采用【unit16】和【int16】数据类型
 对于计算灰度的操作（如傅里叶变换），使用【double】和【single】类型；若图像是【double】或【single】，灰度图像的值通常被归一化标定位【0-1】范围内，0代表黑色，1代表白色，0到1之间的小数表示不同的灰度等级。
 二值图像可以看成是灰度图像的一个特例。
  二值图像  一幅二值图像的二维矩阵仅由0、1两个值构成，计算机中二值图像的数据类型通常为1个二进制位
 在MATLAB中，二值图像具有非常特殊的意义，只有逻辑数据类型【logical】才被认为是二值图像，就算是只包含0和1的数据类的数组（例如【uint8】），在MATLAB中都不认为是二值图像。可以使用logical将其他类型的数组转换为二值图像：B = logical（A）
  索引图像  包括一个数据矩阵X，一个颜色映像矩阵Map。Map是一个包含三列，若干行的数据阵列，其中每个元素的值均为[0，1]之间的双精度浮点型数据。每一行分别表示红， 绿，蓝的颜色值。
 在MATLAB中，索引图像是从像素值到颜色映射表值的“直接映射”。像素颜色由数据矩阵X作为索引指向矩阵Map进行索引，例如，值1指向矩阵Map中的第一行，值2指向第二行，以此类推。
 一般索引图像只能显示256种颜色（由数据矩阵X的取值范围决定），与灰度图像不同的是，灰度图像的颜色表的值是从0到255连续的值，所以灰度图像的数据我们即可以看成是实际的像素值，也可以看成是索引值。
 索引图的优点是存储所需容量小，且索引图像一般用于存放色彩要求比较简单的图像，如Windows中色彩构成比较简单的壁纸多采用索引图像存放，如果图像的色彩比较复杂，就要用到RGB真彩色图像。
  RGB图像  RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中
 一副大小为M*N的RGB图像需要3个M*N大小的矩阵表示，每一个矩阵代表一个颜色通道。RGB图像的数据类型一般为【unit】（或【double】），通常用于表示和存放真彩色图像（2^24种颜色），也可存灰度图像（三个通道的值都一样）
 在MATLAB中用cat操作将3通道合成彩色图像：rab_image = cat(3, R, G, B);
 MATLAB中用下面这些命令可以提取出三个通道的图像：
R = rgb_image（：，：，1）; G = rgb_image（：，：，2）; B = rgb_image（：，：，3）;   </description>
    </item>
    
  </channel>
</rss>