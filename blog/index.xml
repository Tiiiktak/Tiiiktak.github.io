<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Tiiktak&#39;s -- 编程学习与技术分享</title>
    <link>http://konosuba.xyz/blog/</link>
    <description>Recent content in Blog on Tiiktak&#39;s -- 编程学习与技术分享</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 23 Oct 2019 23:25:14 +0800</lastBuildDate>
    
	<atom:link href="http://konosuba.xyz/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【项目笔记】利用OpenCV的MLS图像扭曲变形实现</title>
      <link>http://konosuba.xyz/blog/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E5%88%A9%E7%94%A8opencv%E7%9A%84mls%E5%9B%BE%E5%83%8F%E6%89%AD%E6%9B%B2%E5%8F%98%E5%BD%A2%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 23 Oct 2019 23:25:14 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0%E5%88%A9%E7%94%A8opencv%E7%9A%84mls%E5%9B%BE%E5%83%8F%E6%89%AD%E6%9B%B2%E5%8F%98%E5%BD%A2%E5%AE%9E%E7%8E%B0/</guid>
      <description>引 这学期开学的时候实验室接了个项目，要做一个类似Adobe Illustrator中的“操纵扭曲”功能的Demo
 就像这样
 需求分析 可见需要实现的功能核心就是通过鼠标的拖拽对图像进行扭曲变形，这里的变形主要可以分为两类：
 鼠标拖拽导致的普通变形
 在某一固定锚点基础上的旋转式变形
  确定方案 明确了这个后我便开始查阅资料，发现这篇paper 《Image Deformation Using Moving Least Squares》 中利用了MLS移动最小二乘来实现图像变形，其实现的效果和我们的目标极为相似，于是我也决定利用该算法来实现这个Demo
由于要利用鼠标拖拽进行操作，便选择使用Qt来进行图形化界面设计，然鹅我以前也没有用过Qt，因此学习了一些Qt基本知识
开始吧 明确了方案和目标后，便开始了漫长的学习+实践：
 程序结构框架确定
 核心算法实现
 旋转式变形的实现
  在进行到这里之后，发现程序无法实现对某个关节的单独拉伸，于是我们考虑寻找图像中的骨骼，在关节的交点添加一些锚点进行固定
 图形骨骼查找  实现效果 最终项目完成，实现了这些功能，如图是个小小的演示
本文将会持续更新</description>
    </item>
    
    <item>
      <title>【转载】谷歌小姐姐搞出魔法画板：你随便画，补不齐算AI输</title>
      <link>http://konosuba.xyz/blog/%E8%BD%AC%E8%BD%BD%E8%B0%B7%E6%AD%8C%E5%B0%8F%E5%A7%90%E5%A7%90%E6%90%9E%E5%87%BA%E9%AD%94%E6%B3%95%E7%94%BB%E6%9D%BF%E4%BD%A0%E9%9A%8F%E4%BE%BF%E7%94%BB%E8%A1%A5%E4%B8%8D%E9%BD%90%E7%AE%97ai%E8%BE%93/</link>
      <pubDate>Sun, 20 Oct 2019 00:45:31 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E8%BD%AC%E8%BD%BD%E8%B0%B7%E6%AD%8C%E5%B0%8F%E5%A7%90%E5%A7%90%E6%90%9E%E5%87%BA%E9%AD%94%E6%B3%95%E7%94%BB%E6%9D%BF%E4%BD%A0%E9%9A%8F%E4%BE%BF%E7%94%BB%E8%A1%A5%E4%B8%8D%E9%BD%90%E7%AE%97ai%E8%BE%93/</guid>
      <description>最近在研究手绘图形识别相关的内容，想起了这篇去年的文章，研究的内容也大致差不多，考虑使用Google的循环神经网络，于是转载过来记录一下
原文发表于2018-12-19
这两天，一个“魔法画板”在国外传疯了。
AI圈内外的灵魂画手们玩到根本停不下来，创造的惊喜画作能装满好几个美术馆。
这个画板背后，可不是一个普通的画画AI。它，会脑补。
随便画一笔，就能得到一只猫：
画个圆圈，变成猫：
画个三角，变成猫：
画个方块，变成猫：
真是万物皆可喵喵。
当然，你也可以不让它画猫，改成画狗。只要你设定了一个绘画的目标，之后随便画一笔，AI就能脑补出余下的画面。
这个“魔法”，是来自谷歌的吸猫少女Monica Dinculescu用Sketch RNN开发的。
因为她爱猫成痴，不仅自己头像是和自家喵子的合影，连个人主页域名都叫Meowni.ca，我们就叫她喵妮卡好了。
所以，受到创作者的影响，这个AI默认属性为吸猫爱好者，但除了猫之外，AI也会脑补许多其他内容，脑洞很大。
发布之后，众人竞相玩耍，好评如潮，2000多人点赞。
有人让AI画了满屏的骷髅，说，好美啊！
谷歌大佬David Ha也表示，他已经试过用各种基本形状来教导AI画羊了。
不止有魔力，还可以加戏 喵妮卡给应用起名为魔法画板 (Magic Sketchpad) ，也名副其实。
毕竟，只要画一笔，妈咪妈咪哄！一整张图就出现在眼前。
△ 你想要什么样的美人鱼？
而且，只要按一下选择栏左边的刷新按钮，AI就会根据刚才那一笔，不断为你展现新的画法。
一共有100多种东西可以画，青蛙，秋千，直升飞机，连龙猫里的猫巴士都有。
我是一只豆豆眼的猫头鹰：
我是一只很鬼魅的仙人掌：
为了这100多种选项，都能找到合适的色彩来诠释，画板还提供了18种颜色的画笔。
这样一来，就有数不清的排列组合。有大胆想法的小伙伴们，可以在魔法画板上尽情加戏了。
在你开始表演之前，量子位先抛抛砖：
鲸鱼喷出的不一定是水，也有可能是花。
牙刷上方温柔的曲线不一定是牙膏，也有可能是蜗牛。
另外，如果你还没想到，除了排列组合之外，还可以鬼畜啊。
一头鲸鱼喷水没什么，十几头鲸一起喷，就很有节奏感了 (误) 。
一个人做瑜伽太孤单了，十几个人一起做，姿态各不相同，清明瑜伽图岂不美哉？
不过虽然好玩，量子位似乎还是发现了一个bug，像猫巴士 (Catbus) 这种组合选项：画方成车，画圆成猫，无法兼顾。那么，怎样才能一步生成下面这样的效果呢？
想要体验一下的盆友，传送门照例在文末~
人家是有背景的 可能你已经发觉了，它的画风很像的谷歌推出的Quick, Draw!，中文名为“猜画小歌”。
是的，他们是一家人。
喵妮卡在推特上说了，她的魔法画板使用的就是Quick, Draw!数据集。
这个数据集里面，有5000万张画，分为345个类别。每一张画，都记录了画画的整个过程：画笔运动的方向，何时提笔，何时停止绘画。
如果你玩过猜画小歌，那这个数据集里，也有你的一份贡献。
既然使用的是Quick, Draw!数据集，模型基本上没有什么悬念。
正是Sketch-RNN。这是一个用Quick, Draw！数据集训练出来循环神经网络（RNN）。目标是让AI以类似人类的方式来画画，并概括出抽象的概念。
模型有这样的能力，做出来魔法画板也就没有那么难了。
你随手画个圈，就是为Sketch-RNN输入了一个序列，它可以根据这个序列和你选择要画的东西，预测接下来的序列：也就是补完这幅画。
虽然画风奇特，但画啥就有点像啥。
具体的实现代码，喵妮卡也全部放出来了。（传送门在文末。）
三种额外玩法 除了这个万物皆可喵的网页之外，喵妮卡所在的Google Magenta团队还用Sketch-RNN创作了几个不同的涂鸦应用。
9×N种预测，总能猜中你的心 你涂鸦的每一笔，都被我预料到了。
无论你画了个啥，我都能猜出你接下来准备如何下笔。
并且，我有无数种方案，只要点击predict，就可以出现新的9种图案。</description>
    </item>
    
    <item>
      <title>第一个TensorFlow模型：摄氏度转换为华氏度</title>
      <link>http://konosuba.xyz/blog/%E7%AC%AC%E4%B8%80%E4%B8%AAtensorflow%E6%A8%A1%E5%9E%8B%E6%91%84%E6%B0%8F%E5%BA%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%8E%E6%B0%8F%E5%BA%A6/</link>
      <pubDate>Fri, 11 Oct 2019 20:33:51 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E7%AC%AC%E4%B8%80%E4%B8%AAtensorflow%E6%A8%A1%E5%9E%8B%E6%91%84%E6%B0%8F%E5%BA%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%8E%E6%B0%8F%E5%BA%A6/</guid>
      <description>今天开始在看Udacity上的TensorFlow入门课程，其中构建的第一个神经网络模型就是将摄氏度转换成华氏度，于是在这里记录一下
公式 已知摄氏度转换成华氏度有数学公式：
f = c * 1.8 + 32  而我们就要在不告知模型这个公式的前提下，通过告知一系列对应的摄氏度与华氏度样例，来训练它以实现摄氏度转华氏度这一功能
import dependencies 导入依赖项 需要引入TensorFlow与NumPy库构建神经网络
from __future__ import absolute_import, division, print_function, unicode_literals import tensorflow as tf import numpy as np  还需要引入logging以记录日志
import logging logger = tf.get_logger() #返回tf的日志实例 logger.setLevel(logging.ERROR)  Set up training data 建立训练数据 由于在这里我们使用的是监督式机器学习，所以准备两组链表celsius_q和fahrenheit_a分别代表摄氏温度与对应华氏温度，用来训练模型
celsius_q = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float) fahrenheit_a = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float) for i,c in enumerate(celsius_q): print(&amp;quot;{} degrees Celsius = {} degrees Fahrenheit&amp;quot;.</description>
    </item>
    
    <item>
      <title>Python中eval()与format()</title>
      <link>http://konosuba.xyz/blog/python%E4%B8%ADeval%E4%B8%8Eformat/</link>
      <pubDate>Thu, 10 Oct 2019 20:37:31 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E4%B8%ADeval%E4%B8%8Eformat/</guid>
      <description>今天在做mooc课程《Python语言程序设计》的练习题时，遇到一道题，硬生生纠结了半个小时，结果发现答案居然只是短短的两行，这功力不够果然还是不行啊，用C的思维去写Python怕是要纠结死🤔
先看看题
题目 数值运算
描述 获得用户输入的一个字符串，格式如下：
M OP N  其中，M和N是任何数字，OP代表一种操作，表示为如下四种：+, -, *, /（加减乘除）
根据OP，输出M OP N‬的运算结果，统一保留小数点后两位
注意：M和OP、OP和N之间可以存在多个空格，不考虑输入错误情况
示例输入‪ 10 + 100 1 / 20  示例输出 110.00 0.05  解答 我最开始的想法是读入字符串，然后根据空格分为M、OP和N，之后再转换为int型进行计算
然而，我却完全忘记了Python有着eval()的存在&amp;hellip;.
eval() |eval()函数用来执行一个字符串表达式，并返回表达式的值 ‬‪‬‪‬‪‬‮‬‪‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫
eval(expression[, globals[, locals]])   参数
expression &amp;ndash; 表达式
globals &amp;ndash; 变量作用域，全局命名空间，若被提供，必须是一个字典对象
locals &amp;ndash; 变量作用域，局部命名空间，若被提供，可以是任何映射对象
 可见，使用eval()后，就不需要我们自己对用户输入的算式进行处理，只需要直接调用，函数会自动帮我们计算结果
之后根据题意，我们还要将运算结果保留两位小数，这时format()就派上了用场
format() 这是一种格式化字符串的函数，基本语法是使用{}和: ‪‬‪‬‪‬‪‬‪‬‮‬‭‬‪‬‪‬‪‬‪‬‪‬‪‬‮ |format()‫‬‪‬‪函数‬‪‬‪‬可以接受不限个参数，位置可以不按顺序
&amp;gt;&amp;gt;&amp;gt; &amp;quot;{} {}&amp;quot;.format(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;) # 不设置指定位置，按默认顺序 &#39;hello world&#39; &amp;gt;&amp;gt;&amp;gt; &amp;quot;{0} {1}&amp;quot;.format(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;) # 设置指定位置 &#39;hello world&#39; &amp;gt;&amp;gt;&amp;gt; &amp;quot;{1} {0} {1}&amp;quot;.</description>
    </item>
    
    <item>
      <title>ML学习速率</title>
      <link>http://konosuba.xyz/blog/ml%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87/</link>
      <pubDate>Thu, 26 Sep 2019 11:12:23 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/ml%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87/</guid>
      <description>在梯度下降算法中，我们用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。例如，如果梯度大小为 2.5，学习速率为 0.01，则梯度下降法算法会选择距离前一个点 0.025 的位置作为下一个点。
超参数是编程人员在机器学习算法中用于调整的旋钮。大多数机器学习编程人员会花费相当多的时间来调整学习速率。如果学习速率过小，就会花费太长的学习时间：
相同的 U 形曲线。很多点都相互非常接近，它们的轨迹朝着 U 形底部缓慢前进。
相反，如果学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳，就好像量子力学实验出现了严重错误一样：
相同的 U 形曲线。这条曲线包含的点非常少。点的轨迹会跳过 U 形底部，然后再次跳回。
每个回归问题都存在一个“恰好”的学习速率，这个值与损失函数的平坦程度有关。例如，若已知损失函数的梯度较小，则可以放心地试着采用更大的学习速率，以补偿较小的梯度并获得更大的步长。
相同的 U 形曲线。点的轨迹大约需要 8 步达到最低点。</description>
    </item>
    
    <item>
      <title>降低损失：梯度下降法</title>
      <link>http://konosuba.xyz/blog/%E9%99%8D%E4%BD%8E%E6%8D%9F%E5%A4%B1%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</link>
      <pubDate>Thu, 26 Sep 2019 10:21:04 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E9%99%8D%E4%BD%8E%E6%8D%9F%E5%A4%B1%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</guid>
      <description>假设我们有时间和计算资源来计算权重值w1的所有可能值的损失。对于回归问题，所产生的损失与w1的图形始终是碗状图，如下所示：
图中的最低点，即斜率正好为 0 的位置。这个最小值就是损失函数收敛之处。
梯度下降法的第一个阶段是为w1选择一个起始值（起点）。然而起点并不重要；因此很多算法就直接将w1设为 0 或随机选择一个值。
然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，梯度是偏导数的矢量；它可以让我们了解哪个方向距离目标“更近”或“更远”
梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。
为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加：
然后，梯度下降法会重复此过程，逐渐接近最低点。</description>
    </item>
    
    <item>
      <title>Python文本进度条</title>
      <link>http://konosuba.xyz/blog/python%E6%96%87%E6%9C%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1/</link>
      <pubDate>Thu, 19 Sep 2019 20:59:58 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E6%96%87%E6%9C%AC%E8%BF%9B%E5%BA%A6%E6%9D%A1/</guid>
      <description> 一个小程序，用Python在控制台中打印进度条，主要使用time库对时间进行控制，利用了\r转义符使光标回到当前行首的特性，通过多次打印进度条实现动画效果
代码 import time scale = 50 # 进度条长度 print(&amp;quot;&amp;gt;&amp;gt;执行开始\n&amp;quot;) start = time.perf_counter() # 开始时刻 for i in range(scale+1): a = &#39;|&#39; * i b = &#39;.&#39; * (scale - i) c = (i / scale) * 100 dur = time.perf_counter() - start # 当前用时 print(&amp;quot;\r{:^3.0f}% [{}&amp;gt;&amp;gt;{}] {:.2f}s&amp;quot;.format(c, a, b, dur), end=&#39;&#39;) # 打印进度条 time.sleep(0.1) # 休息时间，调整速度 print(&amp;quot;\n\n&amp;gt;&amp;gt;执行结束&amp;quot;)  效果 </description>
    </item>
    
    <item>
      <title>为什么要定义Mat_类</title>
      <link>http://konosuba.xyz/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89mat_%E7%B1%BB/</link>
      <pubDate>Wed, 18 Sep 2019 21:09:06 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89mat_%E7%B1%BB/</guid>
      <description>内容摘自《OpenCV入门教程》
 在读取矩阵元素时，以及获取矩阵某行的地址时，需要指定数据类型。这样首先需要不停地写&amp;lt;uchar&amp;gt;，让人感觉很繁琐，在繁琐和烦躁中容易犯错。
如下面代码中的错误，用at()获取矩阵元素时错误的使用了double类型。这种错误不是语法错误，因此在编译时编译器不会提醒。在程序运行时，at()函数获取到的不是期望的(i,j)位置处的元素，数据已经越界，但是运行时也未必会报错。这样的错误使得你的程序忽而看上去正常，忽而弹出“段错误”，特别是在代码规模很大时，难以查错。
如果使用Mat_类，那么就可以在变量声明时确定元素的类型， 访问元素时不再需要指定元素类型，即使得代码简洁，又减少了出错的可能性。
上面代码可以用Mat_实现，实现代码如下面例程里的第二个双重for循环。
#include &amp;lt;iostream&amp;gt; #include &amp;quot;opencv2/opencv.hpp&amp;quot; #include &amp;lt;stdio.h&amp;gt; using namespace std; using namespace cv; int main(int argc,char* argv[]) { Mat M(600, 800, CV_8UC1); for(int i = 0; i &amp;lt; M.rows; ++i) { //获取指针时需要指定类型 uchar *p = M.ptr&amp;lt;uchar&amp;gt;(i); for(int j = 0; j &amp;lt; M.cols; ++j) { double d1 = (double)((i + j) % 255); //用at读像素时，需要指定类型 M.at&amp;lt;uchar&amp;gt;(i, j) = d1; double d2 = M.at&amp;lt;uchar&amp;gt;(i, j); } } //在变量声明时，指定矩阵元素类型 Mat_&amp;lt;uchar&amp;gt; M1 = (Mat_&amp;lt;uchar&amp;gt;&amp;amp;)M; for(int i = 0; i &amp;lt; M1.</description>
    </item>
    
    <item>
      <title>Python split()函数</title>
      <link>http://konosuba.xyz/blog/python-split%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 16 Sep 2019 20:13:56 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python-split%E5%87%BD%E6%95%B0/</guid>
      <description>(adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: &#34;ca-pub-9673215637005333&#34;, enable_page_level_ads: true });  原型 str.split(str=&amp;quot;&amp;quot;, num=string.count(str))  |split()函数通过指定分隔符对字符串进行切片
参数 若参数str无指定值。默认为所有的空字符，包括空格、\n、\t等
若参数num有指定值，则分割num+1个子字符串，若无指定值，默认-1，即分隔所有
返回值 返回分割后的字符串列表</description>
    </item>
    
    <item>
      <title>Zen of Python -Python之禅</title>
      <link>http://konosuba.xyz/blog/zen-of-python-python%E4%B9%8B%E7%A6%85/</link>
      <pubDate>Sat, 07 Sep 2019 21:07:51 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/zen-of-python-python%E4%B9%8B%E7%A6%85/</guid>
      <description>在浏览Python官方文档时无意发现了这个彩蛋，只需在终端中import this
The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess.</description>
    </item>
    
    <item>
      <title>Python文件操作</title>
      <link>http://konosuba.xyz/blog/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 07 Sep 2019 20:31:38 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>Python内置了读写文件的函数，用法与C兼容
读文件 open() 使用内置的open()函数，传入文件名和标识符：
&amp;gt;&amp;gt;&amp;gt; f = open(&#39;test.txt&#39;, &#39;r&#39;)  若文件不存在，open()函数会抛出一个IOError的错误，并给出错误码和详细信息
Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; FileNotFoundError: [Errno 2] No such file or directory: &#39;test.txt&#39;  read() 打开成功后，使用read()一次性读取文件的全部内容，Python将内容读到内存中，用str对象存储
readline() |readline()可以每次读取一行的内容
readlines() |readlines()一次读取所有内容并按行返回list
close() 使用完毕后，需要调用close()关闭文件
with语句 为避免忘记调用close()，Python引入with语句自动调用close()
with open(&#39;test.txt&#39;, &#39;r&#39;) as f: print(f.read())  写文件 与读文件类似，唯一区别是传入标识符&#39;w&#39;或&#39;wb&#39;表示写文本文件或写二进制文件
所有标识符定义及其意义见官方文档
file-like Object (file object文件对象) 在Python中，像open()函数返回的这种有read()或write()方法的对象统称为file-like Object（或file object）
共有三种类别的文件对象：原始二进制文件, 缓冲二进制文件 以及 文本文件，创建文件对象的规范方式是使用open()函数。</description>
    </item>
    
    <item>
      <title>Python调试</title>
      <link>http://konosuba.xyz/blog/python%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sat, 07 Sep 2019 19:08:46 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E8%B0%83%E8%AF%95/</guid>
      <description>Python中可以使用断言assert,logging等来进行调试
断言 def fun(s): n = int(s) assert n != 0, &#39;n is zero!&#39; return 10 / n def main(): fun(&#39;0&#39;)  若assert后面的语句不为True，则assert会抛出异常AssertionError，并显示后一句&#39;n is zero&#39;:
Traceback (most recent call last): File &amp;quot;hello.py&amp;quot;, line 12, in &amp;lt;module&amp;gt; main() File &amp;quot;hello.py&amp;quot;, line 9, in main fun(&#39;0&#39;) File &amp;quot;hello.py&amp;quot;, line 4, in fun assert n != 0, &#39;n is zero!&#39; AssertionError: n is zero!  在我们不需要使用assert时可以在启动Python解释器时，添加-O(大写字母O)参数来关闭断言：
..path:&amp;gt; python -O hello.py Traceback (most recent call last): File &amp;quot;hello.</description>
    </item>
    
    <item>
      <title>Python错误处理</title>
      <link>http://konosuba.xyz/blog/python%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 06 Sep 2019 19:14:26 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>在Python中也同样使用try...except...finally...的错误处理机制
try except try: print(&#39;try...&#39;) r = 10/0 print(&#39;result:&#39;, r) except ZeroDivisionError as e: print(&#39;except:&#39;, e) finally: print(&#39;finally...&#39;) print(&#39;END&#39;)  当认为某一块代码有错误时，就可以用try来运行该段代码，若执行出错，则后续代码不会执行，而会跳转到except块，执行完except后，若后续有finally片段，则执行finally块
上面的代码中有一个除0的错误，运行结果:
try... except: division by zero finally... END  当计算r后，捕捉到ZeroDivisionError错误，执行 except语句段，之后执行finally
else 可以在except后面加上else，当没有错误发生时将执行else语句块
try: print(&#39;try...&#39;) r = 10/5 print(&#39;result:&#39;, r) except ZeroDivisionError as e: print(&#39;except:&#39;, e) else: print(&#39;no error&#39;) print(&#39;END&#39;)  结果:
try... result: 2.0 no error END   Python的错误是一个class，所有错误类型都继承自BaseException，故使用except时需注意它会也会捕获该类型的子类。
 常见错误类型及继承关系（中文）：官方文档 ```
  优势 使用try...except捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用fun()，fun()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理</description>
    </item>
    
    <item>
      <title>利用opencv与Socket实现树莓派获取摄像头视频和灰度重心发送到电脑</title>
      <link>http://konosuba.xyz/blog/%E5%88%A9%E7%94%A8opencv%E4%B8%8Esocket%E5%AE%9E%E7%8E%B0%E6%A0%91%E8%8E%93%E6%B4%BE%E8%8E%B7%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E5%92%8C%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E5%8F%91%E9%80%81%E5%88%B0%E7%94%B5%E8%84%91/</link>
      <pubDate>Tue, 09 Jul 2019 15:32:53 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E5%88%A9%E7%94%A8opencv%E4%B8%8Esocket%E5%AE%9E%E7%8E%B0%E6%A0%91%E8%8E%93%E6%B4%BE%E8%8E%B7%E5%8F%96%E6%91%84%E5%83%8F%E5%A4%B4%E8%A7%86%E9%A2%91%E5%92%8C%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E5%8F%91%E9%80%81%E5%88%B0%E7%94%B5%E8%84%91/</guid>
      <description>使用树莓派原装CSI摄像头录制视频并利用灰度重心法获取重心，将图像和重心数据通过Socket实时传输到电脑上
因为需要实现程序一启动便打开摄像头计算数据，同时启动Socket服务器等待客户端连接，所以利用C++11中的thread库通过多线程实现程序
树莓派-服务端 #include &amp;lt;iostream&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;thread&amp;gt; #include &amp;lt;opencv2/opencv.hpp&amp;gt; using namespace cv; using namespace std; #define USEPORT 1234 #define T 20 Mat FRAME; Point PCENTER; //灰度重心法函数 Point gray_center(Mat&amp;amp; img) { Mat img_gray; cvtColor(img, img_gray, COLOR_BGR2GRAY, 0); Point Center; double sumval = 0; MatIterator_&amp;lt;uchar&amp;gt; it, end; for (int i = 0; i &amp;lt; img_gray.cols; i++) { for (int j = 0; j &amp;lt; img_gray.</description>
    </item>
    
    <item>
      <title>Socket通信原理(3)</title>
      <link>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%863/</link>
      <pubDate>Mon, 08 Jul 2019 15:38:20 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%863/</guid>
      <description>本文主要内容为树莓派与PC在局域网内的基于TCP的Socket通信，由于树莓派是Linux系统，而PC是Windows系统，所以要注意一些区别
这里将树莓派作为服务器端，PC作为客户端，连接后服务端向客户端发送信息
服务端-树莓派 socket_server_sms.cpp #include &amp;lt;iostream&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; using namespace std; #define USEPORT 1234 int main() { //****创建套接字 int serverSock = socket(AF_INET, SOCK_STREAM, 0); //Windows中，AF_INET==PF_INET //Linux中，不同的版本这两者有微小差别.对于BSD是AF,对于POSIX是PF if (serverSock &amp;lt; 0) { cout &amp;lt;&amp;lt; &amp;quot;socket creation failed&amp;quot; &amp;lt;&amp;lt; endl; exit(-1); } cout &amp;lt;&amp;lt; &amp;quot;socket creation successfully&amp;quot; &amp;lt;&amp;lt; endl; //****绑定ip和端口 struct sockaddr_in serverAddr; memset(&amp;amp;serverAddr, 0, sizeof(serverAddr)); serverAddr.sin_family = AF_INET; serverAddr.</description>
    </item>
    
    <item>
      <title>Socket通信原理(2)</title>
      <link>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%862/</link>
      <pubDate>Mon, 08 Jul 2019 13:21:57 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%862/</guid>
      <description>本文主要是在计算机本地使用基于TCP协议的Socket建立服务端与客户端的连接与基本通信
 系统：Windows 10
软件：Visual studio 2019
语言：C++
 Socket通信实现步骤  创建ServerSocket和Socket
 打开连接到的Socket的输入/输出流
 按照协议对Socket进行读/写操作
 关闭输入/输出流和Socket
  本文的程序由服务端发送信息到客户端，若用户输入quit则结束客户端与服务端程序
服务端Server 由于Windows下的socket程序依赖Winsock.dll或ws2_32.dll，所以必须提前加载
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;winsock2.h&amp;gt; //包含socket的头文件 #pragma comment (lib, &amp;quot;ws2_32.lib&amp;quot;)	//加载 ws2_32.dll #pragma warning(disable:4996) using namespace std; int main() { //****初始化WSA WSADATA wsaData;	//初始化WSAStartup()函数(规范的版本号，指向WSADATA结构体的指针)，向操作系统说明要使用哪个库的文件 //-&amp;gt;MSKEWORD(2,2)主版本号2，副版本号2 if (WSAStartup(MAKEWORD(2, 2), &amp;amp;wsaData) != 0)	{	return 0; } //****创建套接字 SOCKET servSock = socket(PF_INET, SOCK_STREAM, 0); //参数1，IP地址类型,PF_INET6-&amp;gt;IPv6，PF_INET-&amp;gt;IPv4 //参数2，数据传输方式,SOCK_STREAM 和 SOCK_DGRAM //参数3，传输协议,IPPROTO_TCP 和 IPPTOTO_UDP,写0系统会自动计算处使用那种协议 //判断无效套接字 if (servSock == INVALID_SOCKET) { cout &amp;lt;&amp;lt; &amp;quot;socket error!</description>
    </item>
    
    <item>
      <title>Socket通信原理(1)</title>
      <link>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%861/</link>
      <pubDate>Sun, 07 Jul 2019 11:24:59 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%861/</guid>
      <description>最近在捣鼓树莓派，实验室要用树莓派做图像处理后回传数据到计算机，所以开始学习socket相关知识，这一篇文章主要是计算机网络通信基础。
TCP/IP、UDP 在开始之前，先听两个笑话😏
TCP
&amp;gt; “嗨，我想听一个 TCP 的笑话。” //第一次握手 &amp;gt; “你好，你想听 TCP 的笑话么？” //第二次握手 &amp;gt; “嗯，我想听一个 TCP 的笑话。” //第三次握手 &amp;gt; “好的，我会给你讲一个TCP 的笑话。” &amp;gt; “好的，我会听一个TCP 的笑话。” &amp;gt; “你准备好听一个TCP 的笑话么？” &amp;gt; “嗯，我准备好听一个TCP 的笑话” &amp;gt; “OK，那我要发 TCP 笑话了。大概有 10 秒，20 个字。” &amp;gt; “嗯，我准备收你那个 10 秒时长，20 个字的笑话了。” &amp;gt; “抱歉，你的链接超时了。你好，你想听 TCP 的笑话么？”  UDP
&amp;gt; 我给你们讲个UDP的笑话吧！ &amp;gt; 我给你们讲个UDP的笑话吧！ &amp;gt; 我给你们讲个UDP的笑话吧！ &amp;gt; 我给你们讲个UDP的笑话吧！  学完之后，发现这两个笑话很好的表示出了两种协议的通信方式，来看看
TCP/IP，即传输控制协议/网间协议，是互联网相关各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。UDP是与TCP相对应的协议，属于TCP/IP协议族中的一种
OSI七层模型 OSI是一个理想的模型，一般的网络系统只涉及其中的几层，在七层模型中，每一层都提供一个特殊 的网络功能。
从网络角度观察：
 下面四层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能， 即以节点到节点之间的通信为主</description>
    </item>
    
    <item>
      <title>树莓派配置摄像头</title>
      <link>http://konosuba.xyz/blog/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4/</link>
      <pubDate>Mon, 01 Jul 2019 15:27:39 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E6%91%84%E5%83%8F%E5%A4%B4/</guid>
      <description>注意：树莓派插电时千万不要插拔摄像头！据说十有八九摄像头会GG，我差点就中招了
安装驱动 首先使用ls指令查看是否加载到了对应的video device设备：
ls -al /etc  没有看到设备开始安装驱动
添加驱动设备到文件夹 sudo vim /etc/modules  在文件末尾添加
bcm2835-v412  修改raspberry的启动配置 进入管理中心开启pi camera
sudo raspi-config  选择interfacing option
开启Camera后重启
检查/dev ls -al /dev/ | grep video  有video设备则成功
使用树莓派摄像头 使用raspistill指令
测试 raspistill -o image.jpg   在使用hdml线连接lcd屏和树莓派时运行，显示屏会显示几秒钟摄像头的实时画面，但使用VNC连接时并不会有实时画面
 raspistill相关  -v：查看调试信息 -w：图像宽度 -h：图像高度 -rot：图像旋转角度，仅支持0，90，180，270度 -o：图像输出地址，若文件名为&amp;rsquo;-&amp;lsquo;，将输出发送至标准输出设备 -t：获取图像前等待时间，默认为5000，即5秒 -tl：多久执行一次图像抓取  生成.h246文件 raspistill -o mykeychain.h264 -t 10000 -w 1280 -h 720  错误 在第一次成功调用后，之后再次调用时多次报错：
mmal: No data received from sensor.</description>
    </item>
    
    <item>
      <title>树莓派安装opencv-4.1.0</title>
      <link>http://konosuba.xyz/blog/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85opencv-4.1.0/</link>
      <pubDate>Mon, 01 Jul 2019 15:25:47 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85opencv-4.1.0/</guid>
      <description>主要参考opencv官网文档和博客树莓派+Opencv（一）图像处理
下载安装依赖项 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev  从opencv官网下载v4.1.0的源码 官网
使用CMake编译源码 先解压并进入文件夹 unzip opencv-4.1.0.zip cd opencv-4.1.0  创建一个build文件夹用于编译 mkdir build cd build  运行cmake-gui cmake-gui  选择源码路径和编译路径后电子config开始编译
编译结束后点击generate完成
建立 在build目录执行make开始编译 -j表示使用多少线程编译，树莓派用-j1较稳定，不加数字表示不限制线程
sudo make -j1  博主在这一步编译了四个小时
安装库 在build目录执行
sudo make install  完成后opencv就已经配好了
测试 Python运行 使用这里提供的测试程序测试opencv是否正常
# -*- coding:utf-8 -*- import cv2 import numpy as np cv2.</description>
    </item>
    
    <item>
      <title>灰度重心法</title>
      <link>http://konosuba.xyz/blog/%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E6%B3%95/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E7%81%B0%E5%BA%A6%E9%87%8D%E5%BF%83%E6%B3%95/</guid>
      <description>概念 对于亮度不均匀的目标（如光斑，光条纹），灰度重心法可按目标光强分布求出光强权重质心坐标作为跟踪点，也叫*密度质心算法*。
将灰度值分布中的质心记作光条纹的中心
对于M * N大小的图像f，像素的灰度值凡是超过阈值T的均参与重心处理，于是重心坐标为：
灰度重心法公式 型心法 只可用于二值图像
灰度重心法version 1 灰度重心法version 2 使用Visual Studio 2019测试 根据灰度重心法version 1找光斑中心
代码：
#define T 20 //根据实际情况设定固定阈值 Point grayCenter(Mat&amp;amp; img) { Mat img_gray; cvtColor(img, img_gray, COLOR_BGR2GRAY, 0); Point Center; //中心点 int i, j; double sumval = 0; MatIterator_&amp;lt;uchar&amp;gt; it, end; //获取图像各点灰度值总和 for (it = img_gray.begin&amp;lt;uchar&amp;gt;(), end = img_gray.end&amp;lt;uchar&amp;gt;(); it != end; it++) { ((*it) &amp;gt; T) ? sumval += (*it) : NULL; //小于阈值，取0 } Center.</description>
    </item>
    
    <item>
      <title>Shell学习</title>
      <link>http://konosuba.xyz/blog/shell%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 26 Jun 2019 15:38:32 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/shell%E5%AD%A6%E4%B9%A0/</guid>
      <description>Shell脚本 是一种为shell编写的脚本程序
使用文本编辑器既能编写，拓展名不影响脚本执行
实例：
#!/bin/bash echo &amp;quot;Hello World&amp;quot;   ### 运行脚本 #### 作为可执行程序 将代码保存后，给文件添加可执行权限```+x``` ```sh chmod +x ./test.sh # ./test.sh #执行脚本  作为解释器参数  直接运行解释器，将文件作为其参数 这种方式不需要在文件开头指定解释器信息
/bin/sh test.sh  Shell变量 定义变量 your_name=&amp;quot;Tom&amp;quot;  注意：等号不能有空格
使用变量 在变量前加美元符号$ 还可在变量外添加大括号{}
echo $your_name echo ${your_name}  只读变量 使用readonly命令将变量定义为只读变量，值不能被改变
url=&amp;quot;baidu.com&amp;quot; readonly url  删除变量 使用unset变量删除变量
unset url  Shell字符串 可用单引号，或双引号，也可不用引号
单引号  单引号内任何字符都会原样输出，单引号字符串中变量无效 单引号字符串中不能出现单独一个的单引号，但可成对出现  双引号  双引号里可以有变量 双引号里可以出现转义字符  拼接字符串 text1=&#39;123&#39; text2=&#39;456&#39; echo ${text1}${text2} #输出123456  字符串长度 str1=&amp;quot;abcd&amp;quot; echo ${#str1} #输出4  提取子字符串 从字符串第2个字符开始截取4个字符：</description>
    </item>
    
    <item>
      <title>Vim学习</title>
      <link>http://konosuba.xyz/blog/vim%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 26 Jun 2019 10:33:16 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/vim%E5%AD%A6%E4%B9%A0/</guid>
      <description>vim分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode），底线命令（Last line mode）
命令模式 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。
常用命令：
 i 切换到输入模式，以输入字符 x 删除当前光标所在处的字符 : 切换到底线命令模式，以在最底一行输入命令  命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令
输入模式 常用：
 Esc 退出输入模式，切换到命令模式 Insert 切换光标为输入/替换模式，光标变成竖线/下划线  底线命令模式 基本命令： * q 退出程序 * w 保存文件
vim按键 移动光标 要进行多次移动，例如向下移动30行，可使用30↓的组合按键
 [Ctrl]+[f] 下一页 [Ctrl]+[b] 上一页 [Ctrl]+[d] 向下半页 [Ctrl]+[u] 向上半页 0 移动到该行最前面字符处 $ 移动到该行最后字符处 G 移动到档案最后一行 nG 一赌东道档案第n行 gg 移动到档案第一行  搜索替换  /word 向光标之下寻找名称为word的字符串 ？word 向光标之上寻找名称为word的字符串 n 重复前一个搜寻的动作 N 反向进行前一个搜寻动作 :n1,n2s/word1/word2/g 在n1与n2行之间寻找word1字符串，并用word2取代 :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2，并显示提示字符确认  删除、复制、粘贴  x,X x相当于del，X相当于Backspace dd 删除光标所在行 ndd 删除光标所在向下n行 d1G 删除光标所在到第一行所有数据 dG 删除光标所在到最后一行所有数据 yy 复制光标所在行 nyy 复制光标所在的向下n行 p,P p为将已复制的数据在光标下一行粘贴，P为粘贴在上一行 u 撤销 [Ctrl]+r 重做 .</description>
    </item>
    
    <item>
      <title>Linux文件</title>
      <link>http://konosuba.xyz/blog/linux%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 25 Jun 2019 13:23:08 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/linux%E6%96%87%E4%BB%B6/</guid>
      <description>[toc]
Linux文件基本属性 在Linux中可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如：
[root@www /]# ls -l total 64 dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin dr-xr-xr-x 4 root root 4096 Apr 19 2012 boot ……  bin文件的第一个属性用d表示，d在Linux中代表该文件是一个目录文件 Linux中第一个字符代表这个文件时目录、文件、链接文件等 &amp;gt;* 当为[d]则是目录 &amp;gt;* 当为[-]则是文件 &amp;gt;* 若是[l]则表示为链接文档(link file) &amp;gt;* 若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) &amp;gt;* 若是[c]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)
接下来的字符中，三个为一组，且均为『rwx』 的三个参数的组合。其中，[r]代表可读(read)、[w]代表可写(write)、[x]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[-]，如图
Linux链接 Linux链接分为硬链接（Hard Link）和软链接（Symbolic Link）。默认情况，ln命令创建硬链接
硬链接 硬连接指通过索引节点来进行连接，多个文件名可以指向同一索引节点，删除其中任何一个不会影响其余文件名的访问，只有当最后一个连接被删除时，文件的数据块及其目录的连接才被释放
软链接 即符号链接，类似于Windows中快捷方式。两个文件名指向两个不同的节点号，若被指向的文件删除，链接仍存在，但指向一个无效的链接
Linux文件属主和属组 Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。
[root@www /]# ls -l total 64 drwxr-xr-x 2 root root 4096 Feb 15 14:46 cron drwxr-xr-x 3 mysql mysql 4096 Apr 21 2014 mysql ……  mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</description>
    </item>
    
    <item>
      <title>Linux操作学习 系统启动及目录</title>
      <link>http://konosuba.xyz/blog/linux%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 24 Jun 2019 11:51:27 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/linux%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0-%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%9B%AE%E5%BD%95/</guid>
      <description>Linux系统启动过程   内核的引导 运行init 系统初始化 建立终端 用户登录系统   内核的引导 计算机接通电源，BIOS开机自检，启动操作系统，操作系统接管硬件后，首先读入/boot目录下的内核文件
运行init init进程是所有进程的起点，没有它任何进程都不会启动。init程序首先需要读取配置文件/etc/inittab
运行级别 Linux允许为不同的场合，分配不同的开机启动程序，即“运行级别”(runlevel)。启动时根据运行级别，确定要运行哪些程序
Linux共7种运行级别: &amp;gt;* 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 &amp;gt;* 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 &amp;gt;* 运行级别2：多用户状态(没有NFS) &amp;gt;* 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 &amp;gt;* 运行级别4：系统未使用，保留 &amp;gt;* 运行级别5：X11控制台，登陆后进入图形GUI模式 &amp;gt;* 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
系统初始化 init配置文件中有一行：si::sysinit:/etc/rc.d/rc.sysinit，它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，主要完成一些系统初始化的工作，rc.sysinit是每个运行级别都要首先运行的重要脚本。
主要完成的工作：激活交换分区，检查磁盘，加载硬件模块及其他一些需要优先执行的任务
另外一行：15:5:wait:/etc/rc.d/rc 5，表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，接受5作为参数，执行/etc/rc.d/rc5.d/目录下所有rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。
而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。
这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。
至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&amp;rdquo;System Services&amp;rdquo;来自行设定。
建立终端 rc执行完毕，返回init。此时基本系统环境已设置好，各种守护进程已启动。
init接下来会打开6个终端，以便用户登录系统，即inittab中以下6行就是定义了6个终端：
1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6  2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式，同时显示文本登陆界面
用户登录系统 常用三种登陆方式： * 命令行登陆 * ssh登陆 * 图形界面登陆
命令行登陆 Linux的账号验证程序是login，login会接手mingetty传来的用户名作为用户名参数， 之后login对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login 将输出 nologin 文件的内容，然后退出。</description>
    </item>
    
    <item>
      <title>Python面向对象</title>
      <link>http://konosuba.xyz/blog/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 21 Jun 2019 15:23:06 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>类和实例 定义类 使用class关键字
class Student(object): #class 类名(继承类) 无继承类则使用object,也可省略 &amp;quot;&amp;quot;&amp;quot;docstring for Student&amp;quot;&amp;quot;&amp;quot; def __init__(self, name, score): #初始属性，第一个参数永远是self，表示创建的实例本身 super (Student, self).__init__() self.name = name self.score = score def print_score(self) print(&#39;%s: %s&#39; % (self.name, self.score))  实例化 类名+（）
&amp;gt;&amp;gt;&amp;gt; bob = Student(&#39;Bob&#39;, 98) &amp;gt;&amp;gt;&amp;gt; bob.print_score() Bob: 98  创建实例后，可以自由地给一个实例变量绑定属性，如
&amp;gt;&amp;gt;&amp;gt; bob.school = &#39;SWUST&#39; &amp;gt;&amp;gt;&amp;gt; bob.school &#39;SWUST&#39;  访问限制  private私有变量：变量名以__开头 注意：__name__外部可以访问，是特殊变量  继承和多态 基类：
class Animal(object): def run(self): print(&#39;Animal is running...&#39;)  子类：</description>
    </item>
    
    <item>
      <title>Python函数式编程</title>
      <link>http://konosuba.xyz/blog/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 21 Jun 2019 10:50:55 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</guid>
      <description>[toc]
什么是函数式编程？ 函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。
而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言
高阶函数 Python中函数两个特性 &amp;gt; ### 变量可以指向函数 函数本身可以赋值给变量，通过变量可以调用函数
&amp;gt;&amp;gt;&amp;gt; f = abs &amp;gt;&amp;gt;&amp;gt; f(-10) 10   函数名是变量 把函数名看作变量，可将其指向其他对象，则无法调用原函数
&amp;gt;&amp;gt;&amp;gt; abs = 10 &amp;gt;&amp;gt;&amp;gt; abs(-10) Traceback (most recent call last): File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt; TypeError: &#39;int&#39; object is not callable   传入函数 由于变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
一个最简单的高阶函数：
def add(x, y, f) return f(x) + f(y)  当调用add(-5, -6, abs)时，函数计算abs(-5)+abs(-6)，返回11
 把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式
 Python内建高阶函数 map()函数 |map() 函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回</description>
    </item>
    
    <item>
      <title>算法复杂度</title>
      <link>http://konosuba.xyz/blog/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Fri, 21 Jun 2019 10:40:29 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description> 算法复杂度  总共N个数据 一次操作记为O(1) N次操作记为O(n) 在大部分oj判题系统中时间限制为10^6 =1s  冒泡排序  操作次数: n+(n-1)+(n-2)+&amp;hellip;+n(n-1)/2  快速排序  递归处理数组，每次将数组按照key值在其左右区分出来：比key小放左边，比key大放右边
 例: 5 6 2 4 3 8 取首位（5）为key值
 4 3 2 5 6 8
 4 3 2 5 6 8
  </description>
    </item>
    
    <item>
      <title>Python中set集合</title>
      <link>http://konosuba.xyz/blog/python%E4%B8%ADset%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 20 Jun 2019 16:18:07 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E4%B8%ADset%E9%9B%86%E5%90%88/</guid>
      <description> set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
创建set 传入一个list，重复元素会被自动过滤，显示的顺序并不表示set是有序的
&amp;gt;&amp;gt;&amp;gt; s = set([1, 1, 2, 2, 3, 3]) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3}  添加元素 &amp;gt;&amp;gt;&amp;gt; s.add(4) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 3, 4}  删除元素 &amp;gt;&amp;gt;&amp;gt; s.remove(3) &amp;gt;&amp;gt;&amp;gt; s {1, 2, 4}  交并集 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
&amp;gt;&amp;gt;&amp;gt; s1 = set([1, 2, 3]) &amp;gt;&amp;gt;&amp;gt; s2 = set([2, 3, 4]) &amp;gt;&amp;gt;&amp;gt; s1 &amp;amp; s2 {2, 3} &amp;gt;&amp;gt;&amp;gt; s1 | s2 {1, 2, 3, 4}  </description>
    </item>
    
    <item>
      <title>Python中dict字典</title>
      <link>http://konosuba.xyz/blog/python%E4%B8%ADdict%E5%AD%97%E5%85%B8/</link>
      <pubDate>Thu, 20 Jun 2019 15:15:34 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E4%B8%ADdict%E5%AD%97%E5%85%B8/</guid>
      <description>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度
创建dict &amp;gt;&amp;gt;&amp;gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} &amp;gt;&amp;gt;&amp;gt; d[&#39;Michael&#39;] 95  内部实现方法 先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
加入数据 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
&amp;gt;&amp;gt;&amp;gt; d[&#39;Tony&#39;] = 99 &amp;gt;&amp;gt;&amp;gt; d {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  查询key是否存在 使用in &amp;gt;&amp;gt;&amp;gt; &#39;Thomas&#39; in d False &amp;gt;&amp;gt;&amp;gt; &#39;Bob&#39; in d True  使用get() 如果key不存在，返回None，或者自己指定的value
&amp;gt;&amp;gt;&amp;gt; d.get(&#39;Thomas&#39;) #返回None时Python交互环境不显示 &amp;gt;&amp;gt;&amp;gt; d.get(&#39;Thomas&#39;, -1) -1  删除key 删除一个key，用pop(key)方法，对应的value也会从dict中删除，返回删除的value
&amp;gt;&amp;gt;&amp;gt; d.pop(&#39;Bob&#39;) 75 &amp;gt;&amp;gt;&amp;gt; d {&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  注意 dict内部存放顺序与key放入顺序无关 dict的key必须是不可变对象 实质：哈希表</description>
    </item>
    
    <item>
      <title>Python常见数据类型——Tuple元组</title>
      <link>http://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btuple%E5%85%83%E7%BB%84/</link>
      <pubDate>Thu, 20 Jun 2019 13:46:10 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btuple%E5%85%83%E7%BB%84/</guid>
      <description>tuple和list非常类似，但是tuple一旦初始化就不能修改
[toc]
创建tuple &amp;gt;&amp;gt;&amp;gt; classmates = (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)  此时，classmates这个tuple不能改变，它也没有append()，insert()这样的方法。
其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能将其赋值为另外的元素。
因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
空tuple &amp;gt;&amp;gt;&amp;gt; t = () &amp;gt;&amp;gt;&amp;gt; t ()  只有一个元素的tuple 错误写法 不能直接使用括号()!!!
&amp;gt;&amp;gt;&amp;gt; t = (1) &amp;gt;&amp;gt;&amp;gt; t 1 #定义的不是tuble，而是一个数  正解 加一个逗号，消除歧义
&amp;gt;&amp;gt;&amp;gt; t = (1,) &amp;gt;&amp;gt;&amp;gt; t (1,)  &amp;ldquo;可变&amp;rdquo;的tuble 当tuble中包含list元素时，仍然可以对list进行修改，tuble仍指向该list
&amp;gt;&amp;gt;&amp;gt; t = (1, [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]) &amp;gt;&amp;gt;&amp;gt; t[1][2] = &#39;a&#39; &amp;gt;&amp;gt;&amp;gt; t (1, [&#39;x&#39;, &#39;a&#39;, &#39;z&#39;])  个人理解：tuble相当于一个指针数组，指向每个元素，对元素本身的更改并不会影响tuble的指向</description>
    </item>
    
    <item>
      <title>Python常见数据类型——List列表</title>
      <link>http://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%88%97%E8%A1%A8/</link>
      <pubDate>Thu, 20 Jun 2019 13:44:48 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%88%97%E8%A1%A8/</guid>
      <description>Python常见数据类型——List列表 list是一种有序的集合，可随时增删元素
[toc]
创建list &amp;gt;&amp;gt;&amp;gt; classmates = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &amp;gt;&amp;gt;&amp;gt; len(classmates) 3  访问某个位置元素 使用索引地址访问
&amp;gt;&amp;gt;&amp;gt; classmates[0] &#39;A&#39; &amp;gt;&amp;gt;&amp;gt; classmates[-1] #返回最后一项元素 &#39;C&#39;  追加元素到末尾 &amp;gt;&amp;gt;&amp;gt; classmates.append(&#39;D&#39;) &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  插入元素到指定位置 &amp;gt;&amp;gt;&amp;gt; classmates.insert(1, &#39;Here&#39;) #在指定位置放入元素 &amp;gt;&amp;gt;&amp;gt; classmates [&#39;A&#39;, &#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  删除元素 使用pop 指定索引地址删除，返回删除的值
&amp;gt;&amp;gt;&amp;gt; classmates.pop(0) &#39;A&#39; &amp;gt;&amp;gt;&amp;gt; classmates [&#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  使用del 指定索引地址删除，无返回值
&amp;gt;&amp;gt;&amp;gt; del classmates[1] &amp;gt;&amp;gt;&amp;gt;classmates [&#39;Here&#39;, &#39;C&#39;, &#39;D&#39;]  使用remove 删除指定值的第一次出现，无返回值</description>
    </item>
    
    <item>
      <title>图像基础-图像矩阵</title>
      <link>http://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Thu, 06 Jun 2019 00:35:00 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5/</guid>
      <description>数字图像数据可以用矩阵来表示，因此可以采用矩阵理论和矩阵算法对数字图像进行分析和处理。
在使用OpenCV时，要特别注意其坐标轴与普通x-y轴的转换，我在实际使用过程中就经常在这上面翻车，还是不熟练
图为坐标对照图，转自CSDN，具体忘了</description>
    </item>
    
    <item>
      <title>图像基础-图像分类</title>
      <link>http://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:49 +0800</pubDate>
      
      <guid>http://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</guid>
      <description>  部分内容引用 CSDN爬金字塔的人
 计算机中， 通常以矩阵形式存储图像，根据颜色和灰度多少可以分为灰度图像、二值图像、索引图像和RGB图像
灰度图像  矩阵元素取值范围为[0, 255] （0-黑，255-白），数据类型一般为8位无符号整数【unit8】
 某些领域（如医学成像）采用【unit16】和【int16】数据类型
 对于计算灰度的操作（如傅里叶变换），使用【double】和【single】类型；若图像是【double】或【single】，灰度图像的值通常被归一化标定位【0-1】范围内，0代表黑色，1代表白色，0到1之间的小数表示不同的灰度等级。
 二值图像可以看成是灰度图像的一个特例。
  二值图像  一幅二值图像的二维矩阵仅由0、1两个值构成，计算机中二值图像的数据类型通常为1个二进制位
 在MATLAB中，二值图像具有非常特殊的意义，只有逻辑数据类型【logical】才被认为是二值图像，就算是只包含0和1的数据类的数组（例如【uint8】），在MATLAB中都不认为是二值图像。可以使用logical将其他类型的数组转换为二值图像：B = logical（A）
  索引图像  包括一个数据矩阵X，一个颜色映像矩阵Map。Map是一个包含三列，若干行的数据阵列，其中每个元素的值均为[0，1]之间的双精度浮点型数据。每一行分别表示红， 绿，蓝的颜色值。
 在MATLAB中，索引图像是从像素值到颜色映射表值的“直接映射”。像素颜色由数据矩阵X作为索引指向矩阵Map进行索引，例如，值1指向矩阵Map中的第一行，值2指向第二行，以此类推。
 一般索引图像只能显示256种颜色（由数据矩阵X的取值范围决定），与灰度图像不同的是，灰度图像的颜色表的值是从0到255连续的值，所以灰度图像的数据我们即可以看成是实际的像素值，也可以看成是索引值。
 索引图的优点是存储所需容量小，且索引图像一般用于存放色彩要求比较简单的图像，如Windows中色彩构成比较简单的壁纸多采用索引图像存放，如果图像的色彩比较复杂，就要用到RGB真彩色图像。
  RGB图像  RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中
 一副大小为M*N的RGB图像需要3个M*N大小的矩阵表示，每一个矩阵代表一个颜色通道。RGB图像的数据类型一般为【unit】（或【double】），通常用于表示和存放真彩色图像（2^24种颜色），也可存灰度图像（三个通道的值都一样）
 在MATLAB中用cat操作将3通道合成彩色图像：rab_image = cat(3, R, G, B);
 MATLAB中用下面这些命令可以提取出三个通道的图像：
R = rgb_image（：，：，1）; G = rgb_image（：，：，2）; B = rgb_image（：，：，3）;   </description>
    </item>
    
  </channel>
</rss>