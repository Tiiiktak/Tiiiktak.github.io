<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>多变量线性回归 - Tiiktak&#39;s -- 编程学习与技术分享</title>
    
    <meta name="description" content="多变量梯度下降 与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即：
其中：
我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 多变量线性回归的批量梯度下降算法为：
我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。
Python 代码示例：
def computeCost(X, y, theta): inner = np.power(((X * theta.T) - y), 2) return np.sum(inner) / (2 * len(X))  梯度下降法实践1-特征缩放 在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛
以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。
解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。如图：
最简单的方法是令：x_n = (x_n - miu_n) / s_n ，其中miu_n是平均值，s_n是标准差
梯度下降法实践2—学习率 梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。
也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如0.001）进行比较，但通常看上面这样的图表更好
梯度下降算法的每次迭代受到学习率的影响，如果学习率过小，则达到收敛所需的迭代次数会非常高；如果学习率过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。
通常可以考虑尝试这些学习率：
alpha = 0.01, 0.03, 0.1, 0.3, 1, 3, 10
特征和多项式回归 对于房价预测问题
其中，x1 = frontage(临街宽度)，x2 = depth(纵向深度)，x = frontage * depth = area，则：h(x) = theta0 &#43; theta1*x1 &#43; theta2*x2^2">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s -- 编程学习与技术分享">
    
    
    
  </head>
  <body class="single">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s -- 编程学习与技术分享</a></p>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="https://konosuba.xyz/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">多变量线性回归</h1>
    <div class="post-meta">2020.1.7</div>
  </header>
  <div class="post-content">

<h2 id="多变量梯度下降">多变量梯度下降</h2>

<p>与单变量线性回归类似，在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即：</p>

<p><img src="https://i.loli.net/2020/01/07/9gAqCplvsBV1FmU.png" alt="多变量代价函数" /></p>

<p>其中：</p>

<p><img src="https://i.loli.net/2020/01/07/HanoOstDQYgAPJL.png" alt="多变量函数" /></p>

<p>我们的目标和单变量线性回归问题中一样，是要找出使得代价函数最小的一系列参数。 多变量线性回归的批量梯度下降算法为：</p>

<p><img src="https://i.loli.net/2020/01/07/r2BYEoxOdN5zbUA.png" alt="多变量批量梯度下降" /></p>

<p>我们开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。</p>

<p>Python 代码示例：</p>

<p><img src="https://i.loli.net/2020/01/09/n1MLB6xlymvCT9H.png" alt="代码实现公式" /></p>

<pre><code class="language-py3">def computeCost(X, y, theta):
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))
</code></pre>

<h2 id="梯度下降法实践1-特征缩放">梯度下降法实践1-特征缩放</h2>

<p>在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛</p>

<p>以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 0-2000平方英尺，而房间数量的值则是0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。</p>

<p><img src="https://i.loli.net/2020/01/09/bv5qOBZu9IEpJl1.jpg" alt="房价问题代价函数等高线" /></p>

<p>解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。如图：</p>

<p><img src="https://i.loli.net/2020/01/09/fI69AhN7Gm1UCWb.png" alt="解决方法" /></p>

<p>最简单的方法是令：<code>x_n = (x_n - miu_n) / s_n</code> ，其中<code>miu_n</code>是平均值，<code>s_n</code>是标准差</p>

<h2 id="梯度下降法实践2-学习率">梯度下降法实践2—学习率</h2>

<p>梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法在何时趋于收敛。</p>

<p><img src="https://i.loli.net/2020/01/09/Z5WyIJPivt6VbrK.jpg" alt="J(theta)与迭代次数" /></p>

<p>也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如0.001）进行比较，但通常看上面这样的图表更好</p>

<p>梯度下降算法的每次迭代受到学习率的影响，如果学习率过小，则达到收敛所需的迭代次数会非常高；如果学习率过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</p>

<p>通常可以考虑尝试这些学习率：</p>

<p><code>alpha = 0.01, 0.03, 0.1, 0.3, 1, 3, 10</code></p>

<h2 id="特征和多项式回归">特征和多项式回归</h2>

<p>对于房价预测问题</p>

<p><img src="https://i.loli.net/2020/01/09/ENn8vWd1qXRwZJc.png" alt="房价预测公式" /></p>

<p>其中，<code>x1 = frontage(临街宽度)</code>，<code>x2 = depth(纵向深度)</code>，<code>x = frontage * depth = area</code>，则：<code>h(x) = theta0 + theta1*x1 + theta2*x2^2</code></p>

<p>线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，比如一个二次方模型：<code>h(x) = theta0 + theta1*x1 + theta2*x2^2</code> 或者三次方模型：<code>h(x) = theta0 + theta1*x1 + theta2*x2^2 + theta3*x3^3</code></p>

<p><img src="https://i.loli.net/2020/01/09/lHgMFQmZa4pdS1K.jpg" alt="曲线模型" /></p>

<p>通常我们需要先观察数据然后再决定准备尝试怎样的模型。 另外，我们可以令：<code>x2 = x2^2, x3 = x3^3</code>，从而将模型转化为线性回归模型。</p>

<p>根据函数图形特性，我们还可以使：</p>

<p><img src="https://i.loli.net/2020/01/09/Z6NyMn3GcR5PaIH.png" alt="h_x函数" /></p>

<blockquote>
<p>注：如果我们采用多项式回归模型，在运行梯度下降算法前，特征缩放非常有必要。</p>
</blockquote>

<h2 id="正规方程">正规方程</h2>

<p>对于某些线性回归问题，正规方程方法是更好的解决方案。如</p>

<p><img src="https://i.loli.net/2020/01/09/JPOICkxdrMZX1K4.png" alt="正规方程举例" /></p>

<p>正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：</p>

<p><img src="https://i.loli.net/2020/01/09/rnEUMJqZvWGwcI4.png" alt="J_theta求导" /></p>

<p>即对<code>J(theta)</code>进行求导。</p>

<p>假设我们的训练集特征矩阵为<code>X(包含了x0=1)</code>，并且我们的训练集结果为向量<code>y</code>，则利用正规方程解出向量</p>

<p><img src="https://i.loli.net/2020/01/09/Pu7EpX49MwaKHNV.png" alt="正规方程求得向量theta" /></p>

<blockquote>
<p>对于某些不可逆的矩阵（通常是因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），则无法使用正规方程方法</p>
</blockquote>

<p><img src="https://i.loli.net/2020/01/09/mI3Fg2tOqw16lcB.png" alt="" /></p>

<p>以下表数据为例：</p>

<p><img src="https://i.loli.net/2020/01/09/4DtkCp2aZc7bnHh.png" alt="正规方程表格示例" /></p>

<p>梯度下降与正规方程的比较：</p>

<table>
<thead>
<tr>
<th>梯度下降</th>
<th>正规方程</th>
</tr>
</thead>

<tbody>
<tr>
<td>需要选择学习率<code>Alpha</code></td>
<td>不需要</td>
</tr>

<tr>
<td>需要多次迭代</td>
<td>一次运算得出</td>
</tr>

<tr>
<td>当特征数量<code>n</code>大时也能较好适用</td>
<td>需要计算<code>A的逆</code>如果特征数量<code>n</code>较大则运算代价大，因为矩阵逆的计算时间复杂度为<code>O(n^3)</code>，通常来说当<code>n</code>小于<code>10000</code>时还是可以接受的</td>
</tr>

<tr>
<td>适用于各种类型的模型</td>
<td><strong>只适用于线性模型</strong>，不适合逻辑回归模型等其他模型</td>
</tr>
</tbody>
</table>

<p>只要特征变量的数目并不大，正规方程是一个很好的计算参数<code>theta</code>的替代方法。具体地说，只要特征变量数量小于一万，通常使用正规方程法，而不使用梯度下降法。</p>

<p>对于那些更复杂的学习算法，我们将不得不仍然使用梯度下降法。因此，梯度下降法是一个非常有用的算法，可以用在有大量特征变量的线性回归问题。</p>

<p>但对于这个特定的线性回归模型，标准方程法是一个比梯度下降法更快的替代算法。所以，根据具体的问题，以及你的特征变量的数量，这两种算法都是值得学习的。</p>

<p>正规方程的<code>Python</code>实现:</p>

<pre><code class="language-py3">import numpy as np
    
def normalEqn(X, y):
    theta = np.linalg.inv(X.T@X)@X.T@y 
                    #X.T@X等价于X.T.dot(X)
    return theta
</code></pre>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'tiiktak';
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s -- 编程学习与技术分享</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

