<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Posts - Tiiktak&#39;s</title>
    
    <meta name="description" content="Hey You">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s">
    
    
    
  </head>
  <body class="list">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s</a></p>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">



<header class="page-header">
  <h1>
  Posts
  </h1>
</header>






<article class="post-entry">
  <header class="entry-header">
    <h2>算法复杂度</h2>
  </header>
  <section class="entry-content">
   <p> 算法复杂度  总共N个数据 一次操作记为O(1) N次操作记为O(n) 在大部分oj判题系统中时间限制为10^6 =1s  冒泡排序  操作次数: n&#43;(n-1)&#43;(n-2)&#43;…&#43;n(n-1)/2  快速排序  递归处理数组，每次将数组按照key值在其左右区分出来：比key小放左边，比key大放右边
 例: 5 6 2 4 3 8 取首位（5）为key值
 4 3 2 5 6 8
 4 3 2 5 6 8
  ...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.21</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Python中set集合</h2>
  </header>
  <section class="entry-content">
   <p> set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
创建set 传入一个list，重复元素会被自动过滤，显示的顺序并不表示set是有序的
&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3]) &gt;&gt;&gt; s {1, 2, 3}  添加元素 &gt;&gt;&gt; s.add(4) &gt;&gt;&gt; s {1, 2, 3, 4}  删除元素 &gt;&gt;&gt; s.remove(3) &gt;&gt;&gt; s {1, 2, 4}  交并集 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
&gt;&gt;&gt; s1 = set([1, 2, 3]) &gt;&gt;&gt; s2 = set([2, 3, 4]) &gt;&gt;&gt; s1 &amp; s2 {2, 3} &gt;&gt;&gt; s1 | s2 {1, 2, 3, 4}  ...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/python%E4%B8%ADset%E9%9B%86%E5%90%88/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Python中dict字典</h2>
  </header>
  <section class="entry-content">
   <p>dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度
创建dict &gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} &gt;&gt;&gt; d[&#39;Michael&#39;] 95  内部实现方法 先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。
加入数据 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
&gt;&gt;&gt; d[&#39;Tony&#39;] = 99 &gt;&gt;&gt; d {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  查询key是否存在 使用in &gt;&gt;&gt; &#39;Thomas&#39; in d False &gt;&gt;&gt; &#39;Bob&#39; in d True  使用get() 如果key不存在，返回None，或者自己指定的value
&gt;&gt;&gt; d.get(&#39;Thomas&#39;) #返回None时Python交互环境不显示 &gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1) -1  删除key 删除一个key，用pop(key)方法，对应的value也会从dict中删除，返回删除的value
&gt;&gt;&gt; d.pop(&#39;Bob&#39;) 75 &gt;&gt;&gt; d {&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85, &#39;Tony&#39;: 99}  注意 dict内部存放顺序与key放入顺序无关 dict的key必须是不可变对象 实质：哈希表...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/python%E4%B8%ADdict%E5%AD%97%E5%85%B8/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Python常见数据类型——Tuple元组</h2>
  </header>
  <section class="entry-content">
   <p>tuple和list非常类似，但是tuple一旦初始化就不能修改
[toc]
创建tuple &gt;&gt;&gt; classmates = (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)  此时，classmates这个tuple不能改变，它也没有append()，insert()这样的方法。
其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能将其赋值为另外的元素。
因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
空tuple &gt;&gt;&gt; t = () &gt;&gt;&gt; t ()  只有一个元素的tuple 错误写法 不能直接使用括号()!!!
&gt;&gt;&gt; t = (1) &gt;&gt;&gt; t 1 #定义的不是tuble，而是一个数  正解 加一个逗号，消除歧义
&gt;&gt;&gt; t = (1,) &gt;&gt;&gt; t (1,)  “可变”的tuble 当tuble中包含list元素时，仍然可以对list进行修改，tuble仍指向该list
&gt;&gt;&gt; t = (1, [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]) &gt;&gt;&gt; t[1][2] = &#39;a&#39; &gt;&gt;&gt; t (1, [&#39;x&#39;, &#39;a&#39;, &#39;z&#39;])  个人理解：tuble相当于一个指针数组，指向每个元素，对元素本身的更改并不会影响tuble的指向...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Btuple%E5%85%83%E7%BB%84/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Python常见数据类型——List列表</h2>
  </header>
  <section class="entry-content">
   <p>Python常见数据类型——List列表 list是一种有序的集合，可随时增删元素
[toc]
创建list &gt;&gt;&gt; classmates = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &gt;&gt;&gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;] &gt;&gt;&gt; len(classmates) 3  访问某个位置元素 使用索引地址访问
&gt;&gt;&gt; classmates[0] &#39;A&#39; &gt;&gt;&gt; classmates[-1] #返回最后一项元素 &#39;C&#39;  追加元素到末尾 &gt;&gt;&gt; classmates.append(&#39;D&#39;) &gt;&gt;&gt; classmates [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  插入元素到指定位置 &gt;&gt;&gt; classmates.insert(1, &#39;Here&#39;) #在指定位置放入元素 &gt;&gt;&gt; classmates [&#39;A&#39;, &#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  删除元素 使用pop 指定索引地址删除，返回删除的值
&gt;&gt;&gt; classmates.pop(0) &#39;A&#39; &gt;&gt;&gt; classmates [&#39;Here&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]  使用del 指定索引地址删除，无返回值
&gt;&gt;&gt; del classmates[1] &gt;&gt;&gt;classmates [&#39;Here&#39;, &#39;C&#39;, &#39;D&#39;]  使用remove 删除指定值的第一次出现，无返回值...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.20</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/python%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Blist%E5%88%97%E8%A1%A8/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>图像基础-图像矩阵</h2>
  </header>
  <section class="entry-content">
   <p>数字图像数据可以用矩阵来表示，因此可以采用矩阵理论和矩阵算法对数字图像进行分析和处理。
在使用OpenCV时，要特别注意其坐标轴与普通x-y轴的转换，我在实际使用过程中就经常在这上面翻车，还是不熟练
图为坐标对照图，转自CSDN，具体忘了...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.6</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>图像基础-图像分类</h2>
  </header>
  <section class="entry-content">
   <p>  部分内容引用 CSDN爬金字塔的人
 计算机中， 通常以矩阵形式存储图像，根据颜色和灰度多少可以分为灰度图像、二值图像、索引图像和RGB图像
灰度图像  矩阵元素取值范围为[0, 255] （0-黑，255-白），数据类型一般为8位无符号整数【unit8】
 某些领域（如医学成像）采用【unit16】和【int16】数据类型
 对于计算灰度的操作（如傅里叶变换），使用【double】和【single】类型；若图像是【double】或【single】，灰度图像的值通常被归一化标定位【0-1】范围内，0代表黑色，1代表白色，0到1之间的小数表示不同的灰度等级。
 二值图像可以看成是灰度图像的一个特例。
  二值图像  一幅二值图像的二维矩阵仅由0、1两个值构成，计算机中二值图像的数据类型通常为1个二进制位
 在MATLAB中，二值图像具有非常特殊的意义，只有逻辑数据类型【logical】才被认为是二值图像，就算是只包含0和1的数据类的数组（例如【uint8】），在MATLAB中都不认为是二值图像。可以使用logical将其他类型的数组转换为二值图像：B = logical（A）
  索引图像  包括一个数据矩阵X，一个颜色映像矩阵Map。Map是一个包含三列，若干行的数据阵列，其中每个元素的值均为[0，1]之间的双精度浮点型数据。每一行分别表示红， 绿，蓝的颜色值。
 在MATLAB中，索引图像是从像素值到颜色映射表值的“直接映射”。像素颜色由数据矩阵X作为索引指向矩阵Map进行索引，例如，值1指向矩阵Map中的第一行，值2指向第二行，以此类推。
 一般索引图像只能显示256种颜色（由数据矩阵X的取值范围决定），与灰度图像不同的是，灰度图像的颜色表的值是从0到255连续的值，所以灰度图像的数据我们即可以看成是实际的像素值，也可以看成是索引值。
 索引图的优点是存储所需容量小，且索引图像一般用于存放色彩要求比较简单的图像，如Windows中色彩构成比较简单的壁纸多采用索引图像存放，如果图像的色彩比较复杂，就要用到RGB真彩色图像。
  RGB图像  RGB图像每一个像素的颜色值（由RGB三原色表示）直接存放在图像矩阵中
 一副大小为M*N的RGB图像需要3个M*N大小的矩阵表示，每一个矩阵代表一个颜色通道。RGB图像的数据类型一般为【unit】（或【double】），通常用于表示和存放真彩色图像（2^24种颜色），也可存灰度图像（三个通道的值都一样）
 在MATLAB中用cat操作将3通道合成彩色图像：rab_image = cat(3, R, G, B);
 MATLAB中用下面这些命令可以提取出三个通道的图像：
R = rgb_image（：，：，1）; G = rgb_image（：，：，2）; B = rgb_image（：，：，3）;   ...</p>
  </section>
  <footer class="entry-footer">
    <time>2019.6.6</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="/blog/page/7/">← Prev Page</a>
    
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

