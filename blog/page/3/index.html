<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Posts - Tiiktak&#39;s</title>
    
    <meta name="description" content="Hey You">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s">
    
    
    
  </head>
  <body class="list">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s</a></p>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">



<header class="page-header">
  <h1>
  Posts
  </h1>
</header>






<article class="post-entry">
  <header class="entry-header">
    <h2>【应用机器学习】评估一个假设</h2>
  </header>
  <section class="entry-content">
   <p>检验是否过拟合 将数据分成训练集和测试集 通常用70%的数据作为训练集，用剩下30%的数据作为测试集。
很重要的一点是训练集和测试集均要含有各种类型的数据，通常我们要对数据进行洗牌，然后再分成训练集和测试集。
使用训练集对模型进行训练 可以得到一系列参数 theta
使用测试集对模型进行测试 使用测试集数据对模型进行测试，有两种方式计算误差
线性回归模型 利用测试集数据计算代价函数J
逻辑回归模型 除前述方法，还可使用一种 错误分类(misclassification error)(也称0/1错误分类 zero one misclassification error) 的方法...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.2.7</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E5%BA%94%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%AA%E5%81%87%E8%AE%BE/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>训练神经网络的基本步骤</h2>
  </header>
  <section class="entry-content">
   <p>1. 选择一种网络结构 即选择神经元之间的连通模式
 输入层与输出层单元个数由具体特征决定
 隐藏层通常默认为1层；若为多层，则每个隐藏层单元个数应相等。通常隐藏层单元数越多越好
 隐藏层单元数应与输入特征数相匹配
  2. 随机初始化权重 通常把权重值初始化为接近0的很小的数
3. 执行前向传播FP算法 获得对应于每一个 xi 的 h_theta(xi)​
4. 通过代码计算出代价函数 J(theta) 5. 执行反向传播算法 获得 J(theta) 对于 theta 的偏导​，即
 步骤 3-5
 6. 进行梯度检查  比较 通过反向传播得到的偏导数 与 通过数值计算得到的估计值
 确保两种方法得到基本接近的两个值​
 注意在检查完毕后关闭梯度检查
  7. 利用最优化算法与反向传播算法最小化 J(theta) 比如，使用最小梯度法...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.2.7</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>正则化 Regularization</h2>
  </header>
  <section class="entry-content">
   <p>过拟合的问题 到现在为止，我们已经学习了几种不同的学习算法，包括线性回归和逻辑回归，它们能够有效地解决许多问题，但是当将它们应用到某些特定的机器学习应用时，会遇到过拟合(over-fitting)的问题，可能会导致它们效果很差。
可以使用一种正则化(regularization)的技术来改善或减少过度拟合的问题
在回归问题中  第一个模型是一个线性模型，欠拟合，不能很好地适应我们的训练集；
 第三个模型是一个四次方的模型，过于强调拟合原始数据，而丢失了算法的本质：
  当我们用第三个模型预测新数据，可以看出，若给出一个新的值使之预测，它将表现的很差，是过拟合，虽然能非常好地适应我们的训练集但在新输入变量进行预测时可能会效果不好；而中间的模型似乎是最合适的。
在分类问题中 就以多项式理解， x的次数越高，拟合的越好，但相应的预测的能力就可能变差。
处理过拟合问题
 丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如PCA） 正则化。 保留所有的特征，但是减少参数的大小（magnitude）  代价函数 我们从之前的事例可以看出，正是那些高次项导致了过拟合的产生，所以我们可以通过让这些高次项的系数接近于0，我们就能很好的拟合。
所以正则化的基本方法就是在一定程度上减小高次项系数即参数theta的值
即在设定代价函数时，为高次项的系数设置一些惩罚，通过这样代价函数选择出的theta对预测结果的影响就比之前要小许多。
但如果我们不知道要对哪一个参数进行惩罚，我们可以对所以特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。于是得到了一个较为简单的能防止过拟合问题的假设
其中λ称为正则化参数（Regularization Parameter）。注：根据惯例，我们不对theta0进行惩罚。
经过正则化处理的模型与原模型的可能对比如图：
如果选择的正则化参数λ过大，则会把所有的参数都最小化了，导致模型变成 h(x) = theta0 ，也就是上图中红色直线所示的情况，造成欠拟合。
对于正则化，我们要取一个合理的λ的值，这样才能更好的应用正则化。 回顾一下代价函数，为了使用正则化，让我们把这些概念应用到到线性回归和逻辑回归中去，那么我们就可以让他们避免过度拟合了。
正则化线性回归 正则化线性回归的代价函数为：
如果我们要使用梯度下降法令这个代价函数最小化，因为我们未对theta0进行正则化，所以梯度下降算法将分两种情形：
分类 L1正则化（Lasso回归） 损失函数基础上加上权重参数的绝对值
L2正则化（岭回归） 损失函数基础上加上权重参数的平方和
需要说明的是：L1 相比于 L2 会更容易获得稀疏解
WHY-&gt;Click...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.13</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E6%AD%A3%E5%88%99%E5%8C%96-regularization/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>逻辑回归Logistic Regression</h2>
  </header>
  <section class="entry-content">
   <p>分类问题 在分类问题中，我们需要预测的变量y是离散的值，我们将学习一种叫做逻辑回归 (Logistic Regression) 的算法
在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误）。
将因变量(dependent variable)可能属于的两个类分别称为负向类（negative class）和正向类（positive class），则因变量y ∈ 0,1 ，其中 0 表示负向类，1 表示正向类。
如果我们要用线性回归算法来解决一个分类问题，对于分类，y取值为 0 或者1，但如果你使用的是线性回归，那么假设函数的输出值可能远大于 1，或者远小于0，即使所有训练样本的标签y都等于 0 或 1。尽管我们知道标签应该取值0 或者1，但是如果算法得到的值远大于1或者远小于0的话，就会感觉很奇怪。
所以我们在接下来的要研究的算法就叫做逻辑回归算法，这个算法的性质是：它的输出值永远在0到 1 之间
逻辑回归算法是分类算法，我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上真的是一种分类算法
假说表示 我们引入一个新的模型，逻辑回归，该模型的输出变量范围始终在0和1之间。
逻辑回归模型的假设是：h_theta(x) = g(theta&#39;X) 其中:X代表特征向量，g代表逻辑函数（logistic function)是一个常用的S形函数（Sigmoid function），公式为：g(z) = 1 / (1 &#43; exp(-z)
Python代码实现
import numpy as np def sigmoid(z): return 1 / (1 &#43; np.exp(-z))  该函数图像为
合起来，我们得到逻辑回归模型的假设：
对模型的理解：g(z) = 1 / (1 &#43; exp(-z)
h_theta(x)的作用是，对于给定的输入变量，根据选择的参数计算输出变量=1的可能性（estimated probablity）即h_theta(x) = P(y=1 | x;theta)...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.13</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92logistic-regression/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>Java入门</h2>
  </header>
  <section class="entry-content">
   <p> Java 开发环境配置 首先我们需要下载java开发工具包JDK，下载地址
下载对应版本
之后安装一路下一步即可
安装成功后配置环境变量
参照这个即可
配置完成后，在cmd输入java -version、java、javac，没有报错，则配置成功
基础语法 Java是一门面向对象的语言，因此它就有类与对象、方法、实例变量
 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。  基本语法  大小写敏感 类名首字母大写，”驼峰式”命名 源文件名必须与类名相同 所有的 Java 程序由 public static void main(String []args) 方法开始执行  Hello World public class HelloWorld { public static void main(String []args) { System.out.println(&#34;Hello World&#34;); //自动换行 } }  标识符  所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始 非法标识符举例：123abc、-salary  变量 主要有以下几种变量
 局部变量 类变量（静态变量） 成员变量（非静态变量）  常量 定义变量的时候，如果加上final修饰符，这个变量就变成了常量
常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。
Java 源程序与编译型运行区别 ...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.12</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/java%E5%85%A5%E9%97%A8/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>MATLAB学习_函数</h2>
  </header>
  <section class="entry-content">
   <p>自定义函数 MATLAB可以在单独的.m文件中定义函数
比如有一文件myadd.m，文件中内容为
function y = myadd(a, b) % 这里可以写函数的使用说明，前面以%开头 % 在工作区中，help myadd将显示此处的说明 y = a &#43; b; end %可以略去  第一行function y = myadd(a, b) 告诉 MATLAB，这个函数将返回一个值，并且返回的这个值将被存放于变量y里。
另外，还可以得知这个函数有两个参数a和b，以及定义的函数体，即 y = a &#43; b
 myadd是函数名。以m文件定义的函数必须保存为函数名的形式
要使用 myadd函数，该函数必须在 Matlab 的搜索路径中。
 调用方式 只需在MATLAB中直接使用函数名调用，MATLAB会自动在其搜索路径中找到对应.m文件，例如
&gt;&gt; c = myadd(1, 2) c = 3  MORE MATLAB中允许定义的函数返回值是多个值或多个参数，只需在定义函数时写为
[y1, y2...] = function_name(x1, x2...)...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.11</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/matlab%E5%AD%A6%E4%B9%A0_%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>MATLAB学习_控制语句:for,while,if</h2>
  </header>
  <section class="entry-content">
   <p> for循环 首先我们定义一个向量v = zeros(10, 1)
接着我们写一个 “for” 循环，让v等于 1 到 10。设v(i)等于 2 的i次方，循环最后写上“end”。
&gt;&gt; for i = 1:10 v(i) = 2^i; end &gt;&gt; v v = 2 4 8 16 32 64 128 256 512 1024  同样也可以使用break，continue语句
while &gt;&gt; i = 1 &gt;&gt; while true, v(i) = 999; i = i&#43;1; if i == 6, break; end; end; &gt;&gt; i i = 6  if-else &gt;&gt; if i == 5, disp(&#34;hello&#34;); elseif i == 4, disp(&#34;world&#34;); else disp(&#34;hello, world&#34;); end; hello, world &gt;&gt;  ...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.11</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/matlab%E5%AD%A6%E4%B9%A0_%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5forwhileif/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>MATLAB学习_数据绘图</h2>
  </header>
  <section class="entry-content">
   <p>当开发学习算法时，往往几个简单的图，可以让你更好地理解算法的内容，并且可以完整地检查下算法是否正常运行，是否达到了算法的目的。
二维绘图 我们先来快速生成一些数据用来绘图。
&gt;&gt; t = [0:0.01:0.98]; &gt;&gt; y1 = sin(2*pi*4*t);  如果我们想要绘制正弦函数，只需输入plot(t, y1)，如图
横轴是变量t，纵轴是y1，也就是我们刚刚所输出的正弦函数。
让我们设置y2
&gt;&gt; y2 = cos(2*pi*4*t); &gt;&gt; plot(t, y2)  如果要同时表示正弦和余弦曲线。
我们要做的就是，输入：plot(t, y1)，得到正弦函数，之后使用函数hold on，它的功能是将新的图像绘制在旧的之上
再输入：plot(t, y2)，MATLAB会自动用不同颜色绘制新的曲线，我们也可以指定颜色，比如plot(t, y2, &#39;r&#39;)，r表示使用红色绘制y2
 ‘r’ 为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，&#43;、o 或 * ；
例如，’g:*’ 请求绘制使用 * 标记的绿色点线。’r–‘请求红色虚线
 还可以使用命令xlabel(&#39;time&#39;)标记X轴，输入ylabel(&#39;value&#39;)标记Y轴的值。
同时我们也可以标记这两条函数曲线，用命令 legend(&#39;sin&#39;,&#39;cos&#39;)将这个图例放在右上方，表示这两条曲线表示的内容。最后输入title(&#39;myplot&#39;)，在图像的顶部显示这幅图的标题。
使用close命令可以关掉图像
 可以为图像标号
 使用figure(1); plot(t, y1);将显示第一张图，绘制了y1-t
 使用figure(2); plot(t, y2);将显示第一张图，绘制了y2-t
   subplot命令，我们使用subplot(1,2,1)，它将图像分为一个1*2的格子，也就是前两个参数，然后它使用第一个格子，也就是最后一个参数1的意思。
之后键入plot(t, y1)，y1-t图显示在第一个格子；
使用subplot(1, 2, 2); plot(t, y2)，y2-t图显示在第二个格子
还有一个命令，可以改变轴的刻度，比如改成[0.5 1 -1 1]，输入命令：axis([0....</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.11</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/matlab%E5%AD%A6%E4%B9%A0_%E6%95%B0%E6%8D%AE%E7%BB%98%E5%9B%BE/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>MATLAB学习_字符与字符串</h2>
  </header>
  <section class="entry-content">
   <p>字符串 创建 t = &#34;Hello, world&#34;;  如果文本包含双引号，请在定义中使用两个双引号。
q = &#34;Something &#34;&#34;quoted&#34;&#34; and something else.&#34;  t 和 q 为数组。它们的数据类型是 string。
&gt;&gt; whos t Name Size Bytes Class Attributes t 1x1 166 string   注意: 使用双引号创建字符串数组是在 R2017a 中引入的。
 行末添加 使用&#43;运算符
&gt;&gt; t &#43; &#34;!&#34; ans = &#34;Hello, world!&#34;  求长度 与数值数组类似，字符串数组可以有多个元素。
&gt;&gt; A = [&#34;a&#34;,&#34;bb&#34;,&#34;ccc&#34;; &#34;dddd&#34;,&#34;eeeeee&#34;,&#34;fffffff&#34;] A = 2×3 string 数组 &#34;a&#34; &#34;bb&#34; &#34;ccc&#34; &#34;dddd&#34; &#34;eeeeee&#34; &#34;fffffff&#34;  使用 strlength 函数求数组中每个字符串的长度。...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.11</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/matlab%E5%AD%A6%E4%B9%A0_%E5%AD%97%E7%AC%A6%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"></a>
</article>

<article class="post-entry">
  <header class="entry-header">
    <h2>MATLAB学习_操作数据</h2>
  </header>
  <section class="entry-content">
   <p>文件操作 导入文件 当我们打开 MATLAB 时，我们通常已经在一个默认路径中，这个路径是 MATLAB 的安装位置，使用 pwd 命令可以显示出 MATLAB 当前所处路径。
使用cd命令，可以修改当前路径
使用’ls’命令，可以列出当前路劲中所有文件
要在MATLAB中导入数据文件，可以使用load命令，如：
&gt;&gt; load myData.dat % 或load(&#39;myData.dat&#39;)  之后可以直接输入myData，MATLAB便会打印文件中的数据，此时该文件名便作为一个新变量名
导出文件 退出 MATLAB 后，工作区变量不会保留。使用 save 命令保存数据以供将来使用，
save myfile.mat  通过保存，系统会使用 .mat 扩展名将工作区保存在当前工作文件夹中一个名为 MAT 文件的压缩文件中。
变量操作 “工作区”中包含了在MATLAB创建或从数据文件或其他程序导入的变量
例如先在工作区中创建变量A和B
A = eye(3) B = rand(2, 3)  使用who可以查看当前工作区中所有变量
&gt;&gt; who 您的变量为: A B  还有一个whos，能更详细的查看
&gt;&gt; whos Name Size Bytes Class Attributes A 3x3 72 double B 2x3 48 double  此外，在GUI窗口中也能查看...</p>
  </section>
  <footer class="entry-footer">
    <time>2020.1.10</time>
  </footer>
  <a class="entry-link" href="https://konosuba.xyz/blog/matlab%E5%AD%A6%E4%B9%A0_%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE/"></a>
</article>




<footer class="page-footer">
  <nav class="pagination">
    
    <a class="prev" href="/blog/page/2/">← Prev Page</a>
    
    
    <a class="next" href="/blog/page/4/">Next Page →</a>
    
  </nav>
</footer>


</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

