<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <title>Socket通信原理(2) - Tiiktak&#39;s</title>
    
    <meta name="description" content="本文主要是在计算机本地使用基于TCP协议的Socket建立服务端与客户端的连接与基本通信
 系统：Windows 10
软件：Visual studio 2019
语言：C&#43;&#43;
 Socket通信实现步骤  创建ServerSocket和Socket
 打开连接到的Socket的输入/输出流
 按照协议对Socket进行读/写操作
 关闭输入/输出流和Socket
  本文的程序由服务端发送信息到客户端，若用户输入quit则结束客户端与服务端程序
服务端Server 由于Windows下的socket程序依赖Winsock.dll或ws2_32.dll，所以必须提前加载
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;winsock2.h&gt; //包含socket的头文件 #pragma comment (lib, &quot;ws2_32.lib&quot;)	//加载 ws2_32.dll #pragma warning(disable:4996) using namespace std; int main() { //****初始化WSA WSADATA wsaData;	//初始化WSAStartup()函数(规范的版本号，指向WSADATA结构体的指针)，向操作系统说明要使用哪个库的文件 //-&gt;MSKEWORD(2,2)主版本号2，副版本号2 if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)	{	return 0; } //****创建套接字 SOCKET servSock = socket(PF_INET, SOCK_STREAM, 0); //参数1，IP地址类型,PF_INET6-&gt;IPv6，PF_INET-&gt;IPv4 //参数2，数据传输方式,SOCK_STREAM 和 SOCK_DGRAM //参数3，传输协议,IPPROTO_TCP 和 IPPTOTO_UDP,写0系统会自动计算处使用那种协议 //判断无效套接字 if (servSock == INVALID_SOCKET) { cout &lt;&lt; &quot;socket error!">
    <meta name="author" content="">
    
    <link href="https://konosuba.xyz/css/github-gist.min.css" rel="stylesheet">
    <link href="https://konosuba.xyz/css/style.css" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="https://konosuba.xyz/img/apple-touch-icon.png">
    <link rel="icon" href="https://konosuba.xyz/img/favicon.ico">
    
    <meta name="generator" content="Hugo 0.55.6" />
    
    <link rel="alternate" type="application/atom+xml" href="https://konosuba.xyz/index.xml" title="Tiiktak&#39;s">
    
    
    
  </head>
  <body class="single">
    <header class="header">
      <div class="wrap">
        
        <p class="logo"><a href="https://konosuba.xyz/">Tiiktak&#39;s</a></p>
        
        
        <button class="menu-toggle" type="button"></button>
        
      </div>
    </header>
    
    <nav class="nav">
      <ul class="menu">
        
        <li>
          <a href="/about/">About</a>
        </li>
        
      </ul>
    </nav>
    
    <main class="main">


<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">Socket通信原理(2)</h1>
    <div class="post-meta">2019.7.8</div>
  </header>
  <div class="post-content">

<p>本文主要是在计算机本地使用基于TCP协议的Socket建立服务端与客户端的连接与基本通信</p>

<blockquote>
<p>系统：Windows 10</p>

<p>软件：Visual studio 2019</p>

<p>语言：C++</p>
</blockquote>

<hr />

<h1 id="socket通信实现步骤">Socket通信实现步骤</h1>

<ol>
<li><p>创建ServerSocket和Socket</p></li>

<li><p>打开连接到的Socket的输入/输出流</p></li>

<li><p>按照协议对Socket进行读/写操作</p></li>

<li><p>关闭输入/输出流和Socket</p></li>
</ol>

<p>本文的程序由服务端发送信息到客户端，若用户输入quit则结束客户端与服务端程序</p>

<h1 id="服务端server">服务端Server</h1>

<p>由于Windows下的socket程序依赖Winsock.dll或ws2_32.dll，所以必须提前加载</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;winsock2.h&gt; //包含socket的头文件
#pragma comment (lib, &quot;ws2_32.lib&quot;)	//加载 ws2_32.dll
#pragma warning(disable:4996)
using namespace std; 

int main() 
{
//****初始化WSA
	WSADATA wsaData;	
	//初始化WSAStartup()函数(规范的版本号，指向WSADATA结构体的指针)，向操作系统说明要使用哪个库的文件
	//-&gt;MSKEWORD(2,2)主版本号2，副版本号2
	if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) != 0)		
	{				
		return 0; 
	}
	
//****创建套接字
	SOCKET servSock = socket(PF_INET, SOCK_STREAM, 0); 	
		//参数1，IP地址类型,PF_INET6-&gt;IPv6，PF_INET-&gt;IPv4
		//参数2，数据传输方式,SOCK_STREAM 和 SOCK_DGRAM 
		//参数3，传输协议,IPPROTO_TCP 和 IPPTOTO_UDP,写0系统会自动计算处使用那种协议
	
	//判断无效套接字
	if (servSock == INVALID_SOCKET) 
	{
		cout &lt;&lt; &quot;socket error!&quot; &lt;&lt; endl; 
		return 0; 
	}
	
//****绑定ip和端口
	
	//创建sockaddr_in结构体变量(in指internet)
	sockaddr_in sockAddr; 
	//每个字节都用0填充
	memset(&amp;sockAddr, 0, sizeof(sockAddr));	
	//使用IPv4地址
	sockAddr.sin_family = PF_INET; 
	//设置端口号，用htons()函数转换
	sockAddr.sin_port = htons(1234); 
	//具体的IP地址,32位
	sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;); 

//****绑定套接字bind()
	//参数1，socket服务器端套接字变量
	//参数2，sockaddr结构体变量的指针，sockaddr_in强转
	//参数3，参数2变量的大小，一般使用sizeof()计算
	if (bind(servSock, (SOCKADDR*)&amp; sockAddr, sizeof(SOCKADDR)) == SOCKET_ERROR)
	{
		cout &lt;&lt; &quot;bind error!&quot; &lt;&lt; endl; 
		return 0; 
	}
	cout &lt;&lt; &quot;绑定套接字成功！&quot; &lt;&lt; endl; 

//****开始监听listen()
	//5-最大排队数
	//listen()只让套接字进入监听状态，并没有真正接收请求
	if (listen(servSock, 5) == SOCKET_ERROR) 
	{
		cout &lt;&lt; &quot;listen error!&quot; &lt;&lt; endl; 
	}
	cout &lt;&lt; &quot;服务器已经进入监听状态..&quot; &lt;&lt; endl; 

//****接收客户端请求accept()
	//参数与bind()相同
	//accept()会阻塞程序进行，直到有新的请求到来
	//返回一个新的套接字来和客户端通信，后面使用新的套接字通信
	SOCKADDR clntAddr;
	int nSize = sizeof(SOCKADDR);
	SOCKET clntSock = accept(servSock, (SOCKADDR*)&amp; clntAddr, &amp;nSize);
	cout &lt;&lt; &quot;accept函数执行完毕开始接收用户输入&quot; &lt;&lt; endl;

//****开始通信
	while (1)
	{	
		cout &lt;&lt; &quot;输入一句话并按回车(quit退出)&quot; &lt;&lt; endl; 
		string input; 
		cin &gt;&gt; input; 

		//向客户端发送数据
		send(clntSock, input.c_str(), input.length(), NULL);
		cout &lt;&lt; &quot;数据发送成功&quot; &lt;&lt; endl; 

		//如果输入quit，断开连接
		if (input == &quot;quit&quot;)
			break; 
	}

	//关闭套接字
	closesocket(clntSock);
	closesocket(servSock);

	//终止 DLL 的使用
	WSACleanup();

	return 0;
}
</code></pre>

<h1 id="客户端client">客户端Client</h1>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;WinSock2.h&gt; //包含WinSock2.h头文件
using namespace std; 
#pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll 
#pragma warning(disable:4996)

int main() 
{
//****初始化WSA
	WSADATA wsaData;
	//初始化版本
	WSAStartup(MAKEWORD(2, 2), &amp;wsaData);	

//****创建用户端socket	
	SOCKET sock = socket(PF_INET, SOCK_STREAM, 0);		

//****创建sockAddr结构体
	sockaddr_in sockAddr; 
	//每个字节都用0填充
	memset(&amp;sockAddr, 0, sizeof(sockAddr));		
	//绑定服务器、端口		 
	sockAddr.sin_family = PF_INET;
	sockAddr.sin_port = htons(1234);
	sockAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);

//****建立链接
	connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(SOCKADDR));
	cout &lt;&lt; &quot;客户端发送链接请求&quot; &lt;&lt; endl; 

//****接收服务器传回的数据
	while (1)
	{
		char szBuffer[MAXBYTE] = { 0 };
		recv(sock, szBuffer, MAXBYTE, NULL);
		if (strcmp(szBuffer, &quot;quit&quot;) == 0)
			break;
		cout &lt;&lt; &quot;接受服务器传回的消息函数&quot; &lt;&lt; endl;
		cout &lt;&lt; szBuffer &lt;&lt; endl;
	}

//****关闭套接字、终止使用 DLL
	closesocket(sock);
	WSACleanup();

	return 0;
}
</code></pre>

<h1 id="运行测试">运行测试</h1>

<p>先运行服务器端，再运行客户端</p>

<p>启动服务端：</p>

<p><img src="https://i.loli.net/2019/07/08/5d22f13d176eb27511.png" alt="服务端" /></p>

<p>启动客户端,连接成功</p>

<p><img src="https://i.loli.net/2019/07/08/5d22f179a925990004.png" alt="连接成功" /></p>

<p>发送信息测试：</p>

<p><img src="https://i.loli.net/2019/07/08/5d22f1fe26de566307.png" alt="发送" /></p>

<p>输入quit，客户端和服务端均结束</p>

<p><img src="https://i.loli.net/2019/07/08/5d22f24fe1fab71022.png" alt="结束" /></p>

<hr />

<p>实现成功，接下来要测试<a href="/blog/socket通信原理3">树莓派与PC在局域网内的Socket通信</a></p>
</div>
  <footer class="post-footer">
    
  </footer>
  
  
  
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'tiiktak';
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
  
  
</article>

</main>
<footer class="footer">
  <span>&copy; 2020 <a href="https://konosuba.xyz/">Tiiktak&#39;s</a></span>
  <span>&middot;</span>
  <span>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</span>
  <span>&middot;</span>
  <span>Theme️ <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper</a></span>
</footer>
<script src="https://konosuba.xyz/js/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://konosuba.xyz/js/highlight.min.js" data-no-instant></script>
<script data-no-instant>
  let body;
  function menuToggleListener() {
    body.classList.toggle('blur');
  }
  function setMenuToggleListener() {
    const menuToggle = document.querySelector('.menu-toggle');
    if (!menuToggle) return;
    body = document.querySelector('body');
    menuToggle.addEventListener('click', menuToggleListener);
  }

  hljs.initHighlightingOnLoad();
  setMenuToggleListener();

  InstantClick.on('change', function () {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightBlock(block);
    });
    setMenuToggleListener();
  });
</script>
</body>
</html>

